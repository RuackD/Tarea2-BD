
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Personajes
 * 
 */
export type Personajes = {
  id: number
  nombre: string
  fuerza: number
  fecha_nacimiento: Date
  objeto: string | null
}

/**
 * Model Karts
 * 
 */
export type Karts = {
  id: number
  modelo: string
  color: string
  velocidad_maxima: number | null
  id_personaje: number
}

/**
 * Model Personaje_tiene_trabajo
 * 
 */
export type Personaje_tiene_trabajo = {
  id_trabajo: number
  id_personaje: number
  fecha_inicio: Date
  fecha_termino: Date | null
}

/**
 * Model Trabajos
 * 
 */
export type Trabajos = {
  id: number
  descripcion: string
  sueldo: number
}

/**
 * Model Personaje_habita_reino
 * 
 */
export type Personaje_habita_reino = {
  id_personaje: number
  id_reino: number
  fecha_registro: Date
  es_gobernante: boolean
}

/**
 * Model Reinos
 * 
 */
export type Reinos = {
  id: number
  nombre: string
  ubicacion: string
  superficie: number
}

/**
 * Model Defensas_reinos
 * 
 */
export type Defensas_reinos = {
  id_reinos: number
  id_defensas: number
}

/**
 * Model Defensas
 * 
 */
export type Defensas = {
  id: number
  defensa: string
}

/**
 * Model Diplomacias
 * 
 */
export type Diplomacias = {
  id_reino_1: number
  id_reino_2: number
  es_aliado: boolean | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Personajes
 * const personajes = await prisma.personajes.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Personajes
   * const personajes = await prisma.personajes.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.personajes`: Exposes CRUD operations for the **Personajes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personajes
    * const personajes = await prisma.personajes.findMany()
    * ```
    */
  get personajes(): Prisma.PersonajesDelegate<GlobalReject>;

  /**
   * `prisma.karts`: Exposes CRUD operations for the **Karts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Karts
    * const karts = await prisma.karts.findMany()
    * ```
    */
  get karts(): Prisma.KartsDelegate<GlobalReject>;

  /**
   * `prisma.personaje_tiene_trabajo`: Exposes CRUD operations for the **Personaje_tiene_trabajo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personaje_tiene_trabajos
    * const personaje_tiene_trabajos = await prisma.personaje_tiene_trabajo.findMany()
    * ```
    */
  get personaje_tiene_trabajo(): Prisma.Personaje_tiene_trabajoDelegate<GlobalReject>;

  /**
   * `prisma.trabajos`: Exposes CRUD operations for the **Trabajos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trabajos
    * const trabajos = await prisma.trabajos.findMany()
    * ```
    */
  get trabajos(): Prisma.TrabajosDelegate<GlobalReject>;

  /**
   * `prisma.personaje_habita_reino`: Exposes CRUD operations for the **Personaje_habita_reino** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personaje_habita_reinos
    * const personaje_habita_reinos = await prisma.personaje_habita_reino.findMany()
    * ```
    */
  get personaje_habita_reino(): Prisma.Personaje_habita_reinoDelegate<GlobalReject>;

  /**
   * `prisma.reinos`: Exposes CRUD operations for the **Reinos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reinos
    * const reinos = await prisma.reinos.findMany()
    * ```
    */
  get reinos(): Prisma.ReinosDelegate<GlobalReject>;

  /**
   * `prisma.defensas_reinos`: Exposes CRUD operations for the **Defensas_reinos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defensas_reinos
    * const defensas_reinos = await prisma.defensas_reinos.findMany()
    * ```
    */
  get defensas_reinos(): Prisma.Defensas_reinosDelegate<GlobalReject>;

  /**
   * `prisma.defensas`: Exposes CRUD operations for the **Defensas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defensas
    * const defensas = await prisma.defensas.findMany()
    * ```
    */
  get defensas(): Prisma.DefensasDelegate<GlobalReject>;

  /**
   * `prisma.diplomacias`: Exposes CRUD operations for the **Diplomacias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diplomacias
    * const diplomacias = await prisma.diplomacias.findMany()
    * ```
    */
  get diplomacias(): Prisma.DiplomaciasDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.15.0
   * Query Engine version: 1e7af066ee9cb95cf3a403c78d9aab3e6b04f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Personajes: 'Personajes',
    Karts: 'Karts',
    Personaje_tiene_trabajo: 'Personaje_tiene_trabajo',
    Trabajos: 'Trabajos',
    Personaje_habita_reino: 'Personaje_habita_reino',
    Reinos: 'Reinos',
    Defensas_reinos: 'Defensas_reinos',
    Defensas: 'Defensas',
    Diplomacias: 'Diplomacias'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonajesCountOutputType
   */


  export type PersonajesCountOutputType = {
    kart: number
    personaje_tiene_trabajo: number
    personaje_habita_reino: number
  }

  export type PersonajesCountOutputTypeSelect = {
    kart?: boolean
    personaje_tiene_trabajo?: boolean
    personaje_habita_reino?: boolean
  }

  export type PersonajesCountOutputTypeGetPayload<S extends boolean | null | undefined | PersonajesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PersonajesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PersonajesCountOutputTypeArgs)
    ? PersonajesCountOutputType 
    : S extends { select: any } & (PersonajesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PersonajesCountOutputType ? PersonajesCountOutputType[P] : never
  } 
      : PersonajesCountOutputType




  // Custom InputTypes

  /**
   * PersonajesCountOutputType without action
   */
  export type PersonajesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonajesCountOutputType
     */
    select?: PersonajesCountOutputTypeSelect | null
  }



  /**
   * Count Type TrabajosCountOutputType
   */


  export type TrabajosCountOutputType = {
    personaje_tiene_trabajo: number
  }

  export type TrabajosCountOutputTypeSelect = {
    personaje_tiene_trabajo?: boolean
  }

  export type TrabajosCountOutputTypeGetPayload<S extends boolean | null | undefined | TrabajosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TrabajosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TrabajosCountOutputTypeArgs)
    ? TrabajosCountOutputType 
    : S extends { select: any } & (TrabajosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TrabajosCountOutputType ? TrabajosCountOutputType[P] : never
  } 
      : TrabajosCountOutputType




  // Custom InputTypes

  /**
   * TrabajosCountOutputType without action
   */
  export type TrabajosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TrabajosCountOutputType
     */
    select?: TrabajosCountOutputTypeSelect | null
  }



  /**
   * Count Type ReinosCountOutputType
   */


  export type ReinosCountOutputType = {
    personaje_habita_reino: number
    defensas_reinos: number
    diplomacia1: number
    diplomacia2: number
  }

  export type ReinosCountOutputTypeSelect = {
    personaje_habita_reino?: boolean
    defensas_reinos?: boolean
    diplomacia1?: boolean
    diplomacia2?: boolean
  }

  export type ReinosCountOutputTypeGetPayload<S extends boolean | null | undefined | ReinosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReinosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReinosCountOutputTypeArgs)
    ? ReinosCountOutputType 
    : S extends { select: any } & (ReinosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReinosCountOutputType ? ReinosCountOutputType[P] : never
  } 
      : ReinosCountOutputType




  // Custom InputTypes

  /**
   * ReinosCountOutputType without action
   */
  export type ReinosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReinosCountOutputType
     */
    select?: ReinosCountOutputTypeSelect | null
  }



  /**
   * Count Type DefensasCountOutputType
   */


  export type DefensasCountOutputType = {
    defensas_reinos: number
  }

  export type DefensasCountOutputTypeSelect = {
    defensas_reinos?: boolean
  }

  export type DefensasCountOutputTypeGetPayload<S extends boolean | null | undefined | DefensasCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DefensasCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DefensasCountOutputTypeArgs)
    ? DefensasCountOutputType 
    : S extends { select: any } & (DefensasCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DefensasCountOutputType ? DefensasCountOutputType[P] : never
  } 
      : DefensasCountOutputType




  // Custom InputTypes

  /**
   * DefensasCountOutputType without action
   */
  export type DefensasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DefensasCountOutputType
     */
    select?: DefensasCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Personajes
   */


  export type AggregatePersonajes = {
    _count: PersonajesCountAggregateOutputType | null
    _avg: PersonajesAvgAggregateOutputType | null
    _sum: PersonajesSumAggregateOutputType | null
    _min: PersonajesMinAggregateOutputType | null
    _max: PersonajesMaxAggregateOutputType | null
  }

  export type PersonajesAvgAggregateOutputType = {
    id: number | null
    fuerza: number | null
  }

  export type PersonajesSumAggregateOutputType = {
    id: number | null
    fuerza: number | null
  }

  export type PersonajesMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    fuerza: number | null
    fecha_nacimiento: Date | null
    objeto: string | null
  }

  export type PersonajesMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    fuerza: number | null
    fecha_nacimiento: Date | null
    objeto: string | null
  }

  export type PersonajesCountAggregateOutputType = {
    id: number
    nombre: number
    fuerza: number
    fecha_nacimiento: number
    objeto: number
    _all: number
  }


  export type PersonajesAvgAggregateInputType = {
    id?: true
    fuerza?: true
  }

  export type PersonajesSumAggregateInputType = {
    id?: true
    fuerza?: true
  }

  export type PersonajesMinAggregateInputType = {
    id?: true
    nombre?: true
    fuerza?: true
    fecha_nacimiento?: true
    objeto?: true
  }

  export type PersonajesMaxAggregateInputType = {
    id?: true
    nombre?: true
    fuerza?: true
    fecha_nacimiento?: true
    objeto?: true
  }

  export type PersonajesCountAggregateInputType = {
    id?: true
    nombre?: true
    fuerza?: true
    fecha_nacimiento?: true
    objeto?: true
    _all?: true
  }

  export type PersonajesAggregateArgs = {
    /**
     * Filter which Personajes to aggregate.
     */
    where?: PersonajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personajes to fetch.
     */
    orderBy?: Enumerable<PersonajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personajes
    **/
    _count?: true | PersonajesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonajesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonajesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonajesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonajesMaxAggregateInputType
  }

  export type GetPersonajesAggregateType<T extends PersonajesAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonajes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonajes[P]>
      : GetScalarType<T[P], AggregatePersonajes[P]>
  }




  export type PersonajesGroupByArgs = {
    where?: PersonajesWhereInput
    orderBy?: Enumerable<PersonajesOrderByWithAggregationInput>
    by: PersonajesScalarFieldEnum[]
    having?: PersonajesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonajesCountAggregateInputType | true
    _avg?: PersonajesAvgAggregateInputType
    _sum?: PersonajesSumAggregateInputType
    _min?: PersonajesMinAggregateInputType
    _max?: PersonajesMaxAggregateInputType
  }


  export type PersonajesGroupByOutputType = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date
    objeto: string | null
    _count: PersonajesCountAggregateOutputType | null
    _avg: PersonajesAvgAggregateOutputType | null
    _sum: PersonajesSumAggregateOutputType | null
    _min: PersonajesMinAggregateOutputType | null
    _max: PersonajesMaxAggregateOutputType | null
  }

  type GetPersonajesGroupByPayload<T extends PersonajesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonajesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonajesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonajesGroupByOutputType[P]>
            : GetScalarType<T[P], PersonajesGroupByOutputType[P]>
        }
      >
    >


  export type PersonajesSelect = {
    id?: boolean
    nombre?: boolean
    fuerza?: boolean
    fecha_nacimiento?: boolean
    objeto?: boolean
    kart?: boolean | Personajes$kartArgs
    personaje_tiene_trabajo?: boolean | Personajes$personaje_tiene_trabajoArgs
    personaje_habita_reino?: boolean | Personajes$personaje_habita_reinoArgs
    _count?: boolean | PersonajesCountOutputTypeArgs
  }


  export type PersonajesInclude = {
    kart?: boolean | Personajes$kartArgs
    personaje_tiene_trabajo?: boolean | Personajes$personaje_tiene_trabajoArgs
    personaje_habita_reino?: boolean | Personajes$personaje_habita_reinoArgs
    _count?: boolean | PersonajesCountOutputTypeArgs
  }

  export type PersonajesGetPayload<S extends boolean | null | undefined | PersonajesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Personajes :
    S extends undefined ? never :
    S extends { include: any } & (PersonajesArgs | PersonajesFindManyArgs)
    ? Personajes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'kart' ? Array < KartsGetPayload<S['include'][P]>>  :
        P extends 'personaje_tiene_trabajo' ? Array < Personaje_tiene_trabajoGetPayload<S['include'][P]>>  :
        P extends 'personaje_habita_reino' ? Array < Personaje_habita_reinoGetPayload<S['include'][P]>>  :
        P extends '_count' ? PersonajesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PersonajesArgs | PersonajesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'kart' ? Array < KartsGetPayload<S['select'][P]>>  :
        P extends 'personaje_tiene_trabajo' ? Array < Personaje_tiene_trabajoGetPayload<S['select'][P]>>  :
        P extends 'personaje_habita_reino' ? Array < Personaje_habita_reinoGetPayload<S['select'][P]>>  :
        P extends '_count' ? PersonajesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Personajes ? Personajes[P] : never
  } 
      : Personajes


  type PersonajesCountArgs = 
    Omit<PersonajesFindManyArgs, 'select' | 'include'> & {
      select?: PersonajesCountAggregateInputType | true
    }

  export interface PersonajesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personajes that matches the filter.
     * @param {PersonajesFindUniqueArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonajesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonajesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personajes'> extends True ? Prisma__PersonajesClient<PersonajesGetPayload<T>> : Prisma__PersonajesClient<PersonajesGetPayload<T> | null, null>

    /**
     * Find one Personajes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonajesFindUniqueOrThrowArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonajesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PersonajesFindUniqueOrThrowArgs>
    ): Prisma__PersonajesClient<PersonajesGetPayload<T>>

    /**
     * Find the first Personajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesFindFirstArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonajesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonajesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personajes'> extends True ? Prisma__PersonajesClient<PersonajesGetPayload<T>> : Prisma__PersonajesClient<PersonajesGetPayload<T> | null, null>

    /**
     * Find the first Personajes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesFindFirstOrThrowArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonajesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PersonajesFindFirstOrThrowArgs>
    ): Prisma__PersonajesClient<PersonajesGetPayload<T>>

    /**
     * Find zero or more Personajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personajes
     * const personajes = await prisma.personajes.findMany()
     * 
     * // Get first 10 Personajes
     * const personajes = await prisma.personajes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personajesWithIdOnly = await prisma.personajes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonajesFindManyArgs>(
      args?: SelectSubset<T, PersonajesFindManyArgs>
    ): Prisma.PrismaPromise<Array<PersonajesGetPayload<T>>>

    /**
     * Create a Personajes.
     * @param {PersonajesCreateArgs} args - Arguments to create a Personajes.
     * @example
     * // Create one Personajes
     * const Personajes = await prisma.personajes.create({
     *   data: {
     *     // ... data to create a Personajes
     *   }
     * })
     * 
    **/
    create<T extends PersonajesCreateArgs>(
      args: SelectSubset<T, PersonajesCreateArgs>
    ): Prisma__PersonajesClient<PersonajesGetPayload<T>>

    /**
     * Create many Personajes.
     *     @param {PersonajesCreateManyArgs} args - Arguments to create many Personajes.
     *     @example
     *     // Create many Personajes
     *     const personajes = await prisma.personajes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonajesCreateManyArgs>(
      args?: SelectSubset<T, PersonajesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personajes.
     * @param {PersonajesDeleteArgs} args - Arguments to delete one Personajes.
     * @example
     * // Delete one Personajes
     * const Personajes = await prisma.personajes.delete({
     *   where: {
     *     // ... filter to delete one Personajes
     *   }
     * })
     * 
    **/
    delete<T extends PersonajesDeleteArgs>(
      args: SelectSubset<T, PersonajesDeleteArgs>
    ): Prisma__PersonajesClient<PersonajesGetPayload<T>>

    /**
     * Update one Personajes.
     * @param {PersonajesUpdateArgs} args - Arguments to update one Personajes.
     * @example
     * // Update one Personajes
     * const personajes = await prisma.personajes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonajesUpdateArgs>(
      args: SelectSubset<T, PersonajesUpdateArgs>
    ): Prisma__PersonajesClient<PersonajesGetPayload<T>>

    /**
     * Delete zero or more Personajes.
     * @param {PersonajesDeleteManyArgs} args - Arguments to filter Personajes to delete.
     * @example
     * // Delete a few Personajes
     * const { count } = await prisma.personajes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonajesDeleteManyArgs>(
      args?: SelectSubset<T, PersonajesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personajes
     * const personajes = await prisma.personajes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonajesUpdateManyArgs>(
      args: SelectSubset<T, PersonajesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personajes.
     * @param {PersonajesUpsertArgs} args - Arguments to update or create a Personajes.
     * @example
     * // Update or create a Personajes
     * const personajes = await prisma.personajes.upsert({
     *   create: {
     *     // ... data to create a Personajes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personajes we want to update
     *   }
     * })
    **/
    upsert<T extends PersonajesUpsertArgs>(
      args: SelectSubset<T, PersonajesUpsertArgs>
    ): Prisma__PersonajesClient<PersonajesGetPayload<T>>

    /**
     * Count the number of Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesCountArgs} args - Arguments to filter Personajes to count.
     * @example
     * // Count the number of Personajes
     * const count = await prisma.personajes.count({
     *   where: {
     *     // ... the filter for the Personajes we want to count
     *   }
     * })
    **/
    count<T extends PersonajesCountArgs>(
      args?: Subset<T, PersonajesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonajesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonajesAggregateArgs>(args: Subset<T, PersonajesAggregateArgs>): Prisma.PrismaPromise<GetPersonajesAggregateType<T>>

    /**
     * Group by Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonajesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonajesGroupByArgs['orderBy'] }
        : { orderBy?: PersonajesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonajesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonajesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Personajes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonajesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kart<T extends Personajes$kartArgs= {}>(args?: Subset<T, Personajes$kartArgs>): Prisma.PrismaPromise<Array<KartsGetPayload<T>>| Null>;

    personaje_tiene_trabajo<T extends Personajes$personaje_tiene_trabajoArgs= {}>(args?: Subset<T, Personajes$personaje_tiene_trabajoArgs>): Prisma.PrismaPromise<Array<Personaje_tiene_trabajoGetPayload<T>>| Null>;

    personaje_habita_reino<T extends Personajes$personaje_habita_reinoArgs= {}>(args?: Subset<T, Personajes$personaje_habita_reinoArgs>): Prisma.PrismaPromise<Array<Personaje_habita_reinoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Personajes base type for findUnique actions
   */
  export type PersonajesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * Filter, which Personajes to fetch.
     */
    where: PersonajesWhereUniqueInput
  }

  /**
   * Personajes findUnique
   */
  export interface PersonajesFindUniqueArgs extends PersonajesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personajes findUniqueOrThrow
   */
  export type PersonajesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * Filter, which Personajes to fetch.
     */
    where: PersonajesWhereUniqueInput
  }


  /**
   * Personajes base type for findFirst actions
   */
  export type PersonajesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * Filter, which Personajes to fetch.
     */
    where?: PersonajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personajes to fetch.
     */
    orderBy?: Enumerable<PersonajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personajes.
     */
    cursor?: PersonajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personajes.
     */
    distinct?: Enumerable<PersonajesScalarFieldEnum>
  }

  /**
   * Personajes findFirst
   */
  export interface PersonajesFindFirstArgs extends PersonajesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personajes findFirstOrThrow
   */
  export type PersonajesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * Filter, which Personajes to fetch.
     */
    where?: PersonajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personajes to fetch.
     */
    orderBy?: Enumerable<PersonajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personajes.
     */
    cursor?: PersonajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personajes.
     */
    distinct?: Enumerable<PersonajesScalarFieldEnum>
  }


  /**
   * Personajes findMany
   */
  export type PersonajesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * Filter, which Personajes to fetch.
     */
    where?: PersonajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personajes to fetch.
     */
    orderBy?: Enumerable<PersonajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personajes.
     */
    cursor?: PersonajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personajes.
     */
    skip?: number
    distinct?: Enumerable<PersonajesScalarFieldEnum>
  }


  /**
   * Personajes create
   */
  export type PersonajesCreateArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * The data needed to create a Personajes.
     */
    data: XOR<PersonajesCreateInput, PersonajesUncheckedCreateInput>
  }


  /**
   * Personajes createMany
   */
  export type PersonajesCreateManyArgs = {
    /**
     * The data used to create many Personajes.
     */
    data: Enumerable<PersonajesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Personajes update
   */
  export type PersonajesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * The data needed to update a Personajes.
     */
    data: XOR<PersonajesUpdateInput, PersonajesUncheckedUpdateInput>
    /**
     * Choose, which Personajes to update.
     */
    where: PersonajesWhereUniqueInput
  }


  /**
   * Personajes updateMany
   */
  export type PersonajesUpdateManyArgs = {
    /**
     * The data used to update Personajes.
     */
    data: XOR<PersonajesUpdateManyMutationInput, PersonajesUncheckedUpdateManyInput>
    /**
     * Filter which Personajes to update
     */
    where?: PersonajesWhereInput
  }


  /**
   * Personajes upsert
   */
  export type PersonajesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * The filter to search for the Personajes to update in case it exists.
     */
    where: PersonajesWhereUniqueInput
    /**
     * In case the Personajes found by the `where` argument doesn't exist, create a new Personajes with this data.
     */
    create: XOR<PersonajesCreateInput, PersonajesUncheckedCreateInput>
    /**
     * In case the Personajes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonajesUpdateInput, PersonajesUncheckedUpdateInput>
  }


  /**
   * Personajes delete
   */
  export type PersonajesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
    /**
     * Filter which Personajes to delete.
     */
    where: PersonajesWhereUniqueInput
  }


  /**
   * Personajes deleteMany
   */
  export type PersonajesDeleteManyArgs = {
    /**
     * Filter which Personajes to delete
     */
    where?: PersonajesWhereInput
  }


  /**
   * Personajes.kart
   */
  export type Personajes$kartArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    where?: KartsWhereInput
    orderBy?: Enumerable<KartsOrderByWithRelationInput>
    cursor?: KartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KartsScalarFieldEnum>
  }


  /**
   * Personajes.personaje_tiene_trabajo
   */
  export type Personajes$personaje_tiene_trabajoArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    where?: Personaje_tiene_trabajoWhereInput
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithRelationInput>
    cursor?: Personaje_tiene_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * Personajes.personaje_habita_reino
   */
  export type Personajes$personaje_habita_reinoArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    where?: Personaje_habita_reinoWhereInput
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithRelationInput>
    cursor?: Personaje_habita_reinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * Personajes without action
   */
  export type PersonajesArgs = {
    /**
     * Select specific fields to fetch from the Personajes
     */
    select?: PersonajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonajesInclude | null
  }



  /**
   * Model Karts
   */


  export type AggregateKarts = {
    _count: KartsCountAggregateOutputType | null
    _avg: KartsAvgAggregateOutputType | null
    _sum: KartsSumAggregateOutputType | null
    _min: KartsMinAggregateOutputType | null
    _max: KartsMaxAggregateOutputType | null
  }

  export type KartsAvgAggregateOutputType = {
    id: number | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsSumAggregateOutputType = {
    id: number | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsMinAggregateOutputType = {
    id: number | null
    modelo: string | null
    color: string | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsMaxAggregateOutputType = {
    id: number | null
    modelo: string | null
    color: string | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsCountAggregateOutputType = {
    id: number
    modelo: number
    color: number
    velocidad_maxima: number
    id_personaje: number
    _all: number
  }


  export type KartsAvgAggregateInputType = {
    id?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsSumAggregateInputType = {
    id?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsMinAggregateInputType = {
    id?: true
    modelo?: true
    color?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsMaxAggregateInputType = {
    id?: true
    modelo?: true
    color?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsCountAggregateInputType = {
    id?: true
    modelo?: true
    color?: true
    velocidad_maxima?: true
    id_personaje?: true
    _all?: true
  }

  export type KartsAggregateArgs = {
    /**
     * Filter which Karts to aggregate.
     */
    where?: KartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Karts to fetch.
     */
    orderBy?: Enumerable<KartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Karts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Karts
    **/
    _count?: true | KartsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KartsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KartsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KartsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KartsMaxAggregateInputType
  }

  export type GetKartsAggregateType<T extends KartsAggregateArgs> = {
        [P in keyof T & keyof AggregateKarts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKarts[P]>
      : GetScalarType<T[P], AggregateKarts[P]>
  }




  export type KartsGroupByArgs = {
    where?: KartsWhereInput
    orderBy?: Enumerable<KartsOrderByWithAggregationInput>
    by: KartsScalarFieldEnum[]
    having?: KartsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KartsCountAggregateInputType | true
    _avg?: KartsAvgAggregateInputType
    _sum?: KartsSumAggregateInputType
    _min?: KartsMinAggregateInputType
    _max?: KartsMaxAggregateInputType
  }


  export type KartsGroupByOutputType = {
    id: number
    modelo: string
    color: string
    velocidad_maxima: number | null
    id_personaje: number
    _count: KartsCountAggregateOutputType | null
    _avg: KartsAvgAggregateOutputType | null
    _sum: KartsSumAggregateOutputType | null
    _min: KartsMinAggregateOutputType | null
    _max: KartsMaxAggregateOutputType | null
  }

  type GetKartsGroupByPayload<T extends KartsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KartsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KartsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KartsGroupByOutputType[P]>
            : GetScalarType<T[P], KartsGroupByOutputType[P]>
        }
      >
    >


  export type KartsSelect = {
    id?: boolean
    modelo?: boolean
    color?: boolean
    velocidad_maxima?: boolean
    id_personaje?: boolean
    personaje?: boolean | PersonajesArgs
  }


  export type KartsInclude = {
    personaje?: boolean | PersonajesArgs
  }

  export type KartsGetPayload<S extends boolean | null | undefined | KartsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Karts :
    S extends undefined ? never :
    S extends { include: any } & (KartsArgs | KartsFindManyArgs)
    ? Karts  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje' ? PersonajesGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (KartsArgs | KartsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje' ? PersonajesGetPayload<S['select'][P]> | null :  P extends keyof Karts ? Karts[P] : never
  } 
      : Karts


  type KartsCountArgs = 
    Omit<KartsFindManyArgs, 'select' | 'include'> & {
      select?: KartsCountAggregateInputType | true
    }

  export interface KartsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Karts that matches the filter.
     * @param {KartsFindUniqueArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KartsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KartsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Karts'> extends True ? Prisma__KartsClient<KartsGetPayload<T>> : Prisma__KartsClient<KartsGetPayload<T> | null, null>

    /**
     * Find one Karts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KartsFindUniqueOrThrowArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KartsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KartsFindUniqueOrThrowArgs>
    ): Prisma__KartsClient<KartsGetPayload<T>>

    /**
     * Find the first Karts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsFindFirstArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KartsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KartsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Karts'> extends True ? Prisma__KartsClient<KartsGetPayload<T>> : Prisma__KartsClient<KartsGetPayload<T> | null, null>

    /**
     * Find the first Karts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsFindFirstOrThrowArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KartsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KartsFindFirstOrThrowArgs>
    ): Prisma__KartsClient<KartsGetPayload<T>>

    /**
     * Find zero or more Karts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Karts
     * const karts = await prisma.karts.findMany()
     * 
     * // Get first 10 Karts
     * const karts = await prisma.karts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kartsWithIdOnly = await prisma.karts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KartsFindManyArgs>(
      args?: SelectSubset<T, KartsFindManyArgs>
    ): Prisma.PrismaPromise<Array<KartsGetPayload<T>>>

    /**
     * Create a Karts.
     * @param {KartsCreateArgs} args - Arguments to create a Karts.
     * @example
     * // Create one Karts
     * const Karts = await prisma.karts.create({
     *   data: {
     *     // ... data to create a Karts
     *   }
     * })
     * 
    **/
    create<T extends KartsCreateArgs>(
      args: SelectSubset<T, KartsCreateArgs>
    ): Prisma__KartsClient<KartsGetPayload<T>>

    /**
     * Create many Karts.
     *     @param {KartsCreateManyArgs} args - Arguments to create many Karts.
     *     @example
     *     // Create many Karts
     *     const karts = await prisma.karts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KartsCreateManyArgs>(
      args?: SelectSubset<T, KartsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Karts.
     * @param {KartsDeleteArgs} args - Arguments to delete one Karts.
     * @example
     * // Delete one Karts
     * const Karts = await prisma.karts.delete({
     *   where: {
     *     // ... filter to delete one Karts
     *   }
     * })
     * 
    **/
    delete<T extends KartsDeleteArgs>(
      args: SelectSubset<T, KartsDeleteArgs>
    ): Prisma__KartsClient<KartsGetPayload<T>>

    /**
     * Update one Karts.
     * @param {KartsUpdateArgs} args - Arguments to update one Karts.
     * @example
     * // Update one Karts
     * const karts = await prisma.karts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KartsUpdateArgs>(
      args: SelectSubset<T, KartsUpdateArgs>
    ): Prisma__KartsClient<KartsGetPayload<T>>

    /**
     * Delete zero or more Karts.
     * @param {KartsDeleteManyArgs} args - Arguments to filter Karts to delete.
     * @example
     * // Delete a few Karts
     * const { count } = await prisma.karts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KartsDeleteManyArgs>(
      args?: SelectSubset<T, KartsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Karts
     * const karts = await prisma.karts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KartsUpdateManyArgs>(
      args: SelectSubset<T, KartsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Karts.
     * @param {KartsUpsertArgs} args - Arguments to update or create a Karts.
     * @example
     * // Update or create a Karts
     * const karts = await prisma.karts.upsert({
     *   create: {
     *     // ... data to create a Karts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Karts we want to update
     *   }
     * })
    **/
    upsert<T extends KartsUpsertArgs>(
      args: SelectSubset<T, KartsUpsertArgs>
    ): Prisma__KartsClient<KartsGetPayload<T>>

    /**
     * Count the number of Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsCountArgs} args - Arguments to filter Karts to count.
     * @example
     * // Count the number of Karts
     * const count = await prisma.karts.count({
     *   where: {
     *     // ... the filter for the Karts we want to count
     *   }
     * })
    **/
    count<T extends KartsCountArgs>(
      args?: Subset<T, KartsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KartsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KartsAggregateArgs>(args: Subset<T, KartsAggregateArgs>): Prisma.PrismaPromise<GetKartsAggregateType<T>>

    /**
     * Group by Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KartsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KartsGroupByArgs['orderBy'] }
        : { orderBy?: KartsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KartsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Karts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KartsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje<T extends PersonajesArgs= {}>(args?: Subset<T, PersonajesArgs>): Prisma__PersonajesClient<PersonajesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Karts base type for findUnique actions
   */
  export type KartsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * Filter, which Karts to fetch.
     */
    where: KartsWhereUniqueInput
  }

  /**
   * Karts findUnique
   */
  export interface KartsFindUniqueArgs extends KartsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Karts findUniqueOrThrow
   */
  export type KartsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * Filter, which Karts to fetch.
     */
    where: KartsWhereUniqueInput
  }


  /**
   * Karts base type for findFirst actions
   */
  export type KartsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * Filter, which Karts to fetch.
     */
    where?: KartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Karts to fetch.
     */
    orderBy?: Enumerable<KartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Karts.
     */
    cursor?: KartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Karts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Karts.
     */
    distinct?: Enumerable<KartsScalarFieldEnum>
  }

  /**
   * Karts findFirst
   */
  export interface KartsFindFirstArgs extends KartsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Karts findFirstOrThrow
   */
  export type KartsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * Filter, which Karts to fetch.
     */
    where?: KartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Karts to fetch.
     */
    orderBy?: Enumerable<KartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Karts.
     */
    cursor?: KartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Karts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Karts.
     */
    distinct?: Enumerable<KartsScalarFieldEnum>
  }


  /**
   * Karts findMany
   */
  export type KartsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * Filter, which Karts to fetch.
     */
    where?: KartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Karts to fetch.
     */
    orderBy?: Enumerable<KartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Karts.
     */
    cursor?: KartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Karts.
     */
    skip?: number
    distinct?: Enumerable<KartsScalarFieldEnum>
  }


  /**
   * Karts create
   */
  export type KartsCreateArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * The data needed to create a Karts.
     */
    data: XOR<KartsCreateInput, KartsUncheckedCreateInput>
  }


  /**
   * Karts createMany
   */
  export type KartsCreateManyArgs = {
    /**
     * The data used to create many Karts.
     */
    data: Enumerable<KartsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Karts update
   */
  export type KartsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * The data needed to update a Karts.
     */
    data: XOR<KartsUpdateInput, KartsUncheckedUpdateInput>
    /**
     * Choose, which Karts to update.
     */
    where: KartsWhereUniqueInput
  }


  /**
   * Karts updateMany
   */
  export type KartsUpdateManyArgs = {
    /**
     * The data used to update Karts.
     */
    data: XOR<KartsUpdateManyMutationInput, KartsUncheckedUpdateManyInput>
    /**
     * Filter which Karts to update
     */
    where?: KartsWhereInput
  }


  /**
   * Karts upsert
   */
  export type KartsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * The filter to search for the Karts to update in case it exists.
     */
    where: KartsWhereUniqueInput
    /**
     * In case the Karts found by the `where` argument doesn't exist, create a new Karts with this data.
     */
    create: XOR<KartsCreateInput, KartsUncheckedCreateInput>
    /**
     * In case the Karts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KartsUpdateInput, KartsUncheckedUpdateInput>
  }


  /**
   * Karts delete
   */
  export type KartsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
    /**
     * Filter which Karts to delete.
     */
    where: KartsWhereUniqueInput
  }


  /**
   * Karts deleteMany
   */
  export type KartsDeleteManyArgs = {
    /**
     * Filter which Karts to delete
     */
    where?: KartsWhereInput
  }


  /**
   * Karts without action
   */
  export type KartsArgs = {
    /**
     * Select specific fields to fetch from the Karts
     */
    select?: KartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KartsInclude | null
  }



  /**
   * Model Personaje_tiene_trabajo
   */


  export type AggregatePersonaje_tiene_trabajo = {
    _count: Personaje_tiene_trabajoCountAggregateOutputType | null
    _avg: Personaje_tiene_trabajoAvgAggregateOutputType | null
    _sum: Personaje_tiene_trabajoSumAggregateOutputType | null
    _min: Personaje_tiene_trabajoMinAggregateOutputType | null
    _max: Personaje_tiene_trabajoMaxAggregateOutputType | null
  }

  export type Personaje_tiene_trabajoAvgAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
  }

  export type Personaje_tiene_trabajoSumAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
  }

  export type Personaje_tiene_trabajoMinAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
  }

  export type Personaje_tiene_trabajoMaxAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
  }

  export type Personaje_tiene_trabajoCountAggregateOutputType = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: number
    fecha_termino: number
    _all: number
  }


  export type Personaje_tiene_trabajoAvgAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
  }

  export type Personaje_tiene_trabajoSumAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
  }

  export type Personaje_tiene_trabajoMinAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
    fecha_inicio?: true
    fecha_termino?: true
  }

  export type Personaje_tiene_trabajoMaxAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
    fecha_inicio?: true
    fecha_termino?: true
  }

  export type Personaje_tiene_trabajoCountAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
    fecha_inicio?: true
    fecha_termino?: true
    _all?: true
  }

  export type Personaje_tiene_trabajoAggregateArgs = {
    /**
     * Filter which Personaje_tiene_trabajo to aggregate.
     */
    where?: Personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_tiene_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personaje_tiene_trabajos
    **/
    _count?: true | Personaje_tiene_trabajoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personaje_tiene_trabajoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personaje_tiene_trabajoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personaje_tiene_trabajoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personaje_tiene_trabajoMaxAggregateInputType
  }

  export type GetPersonaje_tiene_trabajoAggregateType<T extends Personaje_tiene_trabajoAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonaje_tiene_trabajo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonaje_tiene_trabajo[P]>
      : GetScalarType<T[P], AggregatePersonaje_tiene_trabajo[P]>
  }




  export type Personaje_tiene_trabajoGroupByArgs = {
    where?: Personaje_tiene_trabajoWhereInput
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithAggregationInput>
    by: Personaje_tiene_trabajoScalarFieldEnum[]
    having?: Personaje_tiene_trabajoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personaje_tiene_trabajoCountAggregateInputType | true
    _avg?: Personaje_tiene_trabajoAvgAggregateInputType
    _sum?: Personaje_tiene_trabajoSumAggregateInputType
    _min?: Personaje_tiene_trabajoMinAggregateInputType
    _max?: Personaje_tiene_trabajoMaxAggregateInputType
  }


  export type Personaje_tiene_trabajoGroupByOutputType = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: Date
    fecha_termino: Date | null
    _count: Personaje_tiene_trabajoCountAggregateOutputType | null
    _avg: Personaje_tiene_trabajoAvgAggregateOutputType | null
    _sum: Personaje_tiene_trabajoSumAggregateOutputType | null
    _min: Personaje_tiene_trabajoMinAggregateOutputType | null
    _max: Personaje_tiene_trabajoMaxAggregateOutputType | null
  }

  type GetPersonaje_tiene_trabajoGroupByPayload<T extends Personaje_tiene_trabajoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Personaje_tiene_trabajoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personaje_tiene_trabajoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personaje_tiene_trabajoGroupByOutputType[P]>
            : GetScalarType<T[P], Personaje_tiene_trabajoGroupByOutputType[P]>
        }
      >
    >


  export type Personaje_tiene_trabajoSelect = {
    id_trabajo?: boolean
    id_personaje?: boolean
    fecha_inicio?: boolean
    fecha_termino?: boolean
    trabajo?: boolean | TrabajosArgs
    personaje?: boolean | PersonajesArgs
  }


  export type Personaje_tiene_trabajoInclude = {
    trabajo?: boolean | TrabajosArgs
    personaje?: boolean | PersonajesArgs
  }

  export type Personaje_tiene_trabajoGetPayload<S extends boolean | null | undefined | Personaje_tiene_trabajoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Personaje_tiene_trabajo :
    S extends undefined ? never :
    S extends { include: any } & (Personaje_tiene_trabajoArgs | Personaje_tiene_trabajoFindManyArgs)
    ? Personaje_tiene_trabajo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'trabajo' ? TrabajosGetPayload<S['include'][P]> :
        P extends 'personaje' ? PersonajesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Personaje_tiene_trabajoArgs | Personaje_tiene_trabajoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'trabajo' ? TrabajosGetPayload<S['select'][P]> :
        P extends 'personaje' ? PersonajesGetPayload<S['select'][P]> :  P extends keyof Personaje_tiene_trabajo ? Personaje_tiene_trabajo[P] : never
  } 
      : Personaje_tiene_trabajo


  type Personaje_tiene_trabajoCountArgs = 
    Omit<Personaje_tiene_trabajoFindManyArgs, 'select' | 'include'> & {
      select?: Personaje_tiene_trabajoCountAggregateInputType | true
    }

  export interface Personaje_tiene_trabajoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personaje_tiene_trabajo that matches the filter.
     * @param {Personaje_tiene_trabajoFindUniqueArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Personaje_tiene_trabajoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Personaje_tiene_trabajoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personaje_tiene_trabajo'> extends True ? Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>> : Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T> | null, null>

    /**
     * Find one Personaje_tiene_trabajo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Personaje_tiene_trabajoFindUniqueOrThrowArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Personaje_tiene_trabajoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Personaje_tiene_trabajoFindUniqueOrThrowArgs>
    ): Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>>

    /**
     * Find the first Personaje_tiene_trabajo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoFindFirstArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Personaje_tiene_trabajoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Personaje_tiene_trabajoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personaje_tiene_trabajo'> extends True ? Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>> : Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T> | null, null>

    /**
     * Find the first Personaje_tiene_trabajo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoFindFirstOrThrowArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Personaje_tiene_trabajoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Personaje_tiene_trabajoFindFirstOrThrowArgs>
    ): Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>>

    /**
     * Find zero or more Personaje_tiene_trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personaje_tiene_trabajos
     * const personaje_tiene_trabajos = await prisma.personaje_tiene_trabajo.findMany()
     * 
     * // Get first 10 Personaje_tiene_trabajos
     * const personaje_tiene_trabajos = await prisma.personaje_tiene_trabajo.findMany({ take: 10 })
     * 
     * // Only select the `id_trabajo`
     * const personaje_tiene_trabajoWithId_trabajoOnly = await prisma.personaje_tiene_trabajo.findMany({ select: { id_trabajo: true } })
     * 
    **/
    findMany<T extends Personaje_tiene_trabajoFindManyArgs>(
      args?: SelectSubset<T, Personaje_tiene_trabajoFindManyArgs>
    ): Prisma.PrismaPromise<Array<Personaje_tiene_trabajoGetPayload<T>>>

    /**
     * Create a Personaje_tiene_trabajo.
     * @param {Personaje_tiene_trabajoCreateArgs} args - Arguments to create a Personaje_tiene_trabajo.
     * @example
     * // Create one Personaje_tiene_trabajo
     * const Personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.create({
     *   data: {
     *     // ... data to create a Personaje_tiene_trabajo
     *   }
     * })
     * 
    **/
    create<T extends Personaje_tiene_trabajoCreateArgs>(
      args: SelectSubset<T, Personaje_tiene_trabajoCreateArgs>
    ): Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>>

    /**
     * Create many Personaje_tiene_trabajos.
     *     @param {Personaje_tiene_trabajoCreateManyArgs} args - Arguments to create many Personaje_tiene_trabajos.
     *     @example
     *     // Create many Personaje_tiene_trabajos
     *     const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Personaje_tiene_trabajoCreateManyArgs>(
      args?: SelectSubset<T, Personaje_tiene_trabajoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personaje_tiene_trabajo.
     * @param {Personaje_tiene_trabajoDeleteArgs} args - Arguments to delete one Personaje_tiene_trabajo.
     * @example
     * // Delete one Personaje_tiene_trabajo
     * const Personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.delete({
     *   where: {
     *     // ... filter to delete one Personaje_tiene_trabajo
     *   }
     * })
     * 
    **/
    delete<T extends Personaje_tiene_trabajoDeleteArgs>(
      args: SelectSubset<T, Personaje_tiene_trabajoDeleteArgs>
    ): Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>>

    /**
     * Update one Personaje_tiene_trabajo.
     * @param {Personaje_tiene_trabajoUpdateArgs} args - Arguments to update one Personaje_tiene_trabajo.
     * @example
     * // Update one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Personaje_tiene_trabajoUpdateArgs>(
      args: SelectSubset<T, Personaje_tiene_trabajoUpdateArgs>
    ): Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>>

    /**
     * Delete zero or more Personaje_tiene_trabajos.
     * @param {Personaje_tiene_trabajoDeleteManyArgs} args - Arguments to filter Personaje_tiene_trabajos to delete.
     * @example
     * // Delete a few Personaje_tiene_trabajos
     * const { count } = await prisma.personaje_tiene_trabajo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Personaje_tiene_trabajoDeleteManyArgs>(
      args?: SelectSubset<T, Personaje_tiene_trabajoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personaje_tiene_trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personaje_tiene_trabajos
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Personaje_tiene_trabajoUpdateManyArgs>(
      args: SelectSubset<T, Personaje_tiene_trabajoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personaje_tiene_trabajo.
     * @param {Personaje_tiene_trabajoUpsertArgs} args - Arguments to update or create a Personaje_tiene_trabajo.
     * @example
     * // Update or create a Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.upsert({
     *   create: {
     *     // ... data to create a Personaje_tiene_trabajo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personaje_tiene_trabajo we want to update
     *   }
     * })
    **/
    upsert<T extends Personaje_tiene_trabajoUpsertArgs>(
      args: SelectSubset<T, Personaje_tiene_trabajoUpsertArgs>
    ): Prisma__Personaje_tiene_trabajoClient<Personaje_tiene_trabajoGetPayload<T>>

    /**
     * Count the number of Personaje_tiene_trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoCountArgs} args - Arguments to filter Personaje_tiene_trabajos to count.
     * @example
     * // Count the number of Personaje_tiene_trabajos
     * const count = await prisma.personaje_tiene_trabajo.count({
     *   where: {
     *     // ... the filter for the Personaje_tiene_trabajos we want to count
     *   }
     * })
    **/
    count<T extends Personaje_tiene_trabajoCountArgs>(
      args?: Subset<T, Personaje_tiene_trabajoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personaje_tiene_trabajoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personaje_tiene_trabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personaje_tiene_trabajoAggregateArgs>(args: Subset<T, Personaje_tiene_trabajoAggregateArgs>): Prisma.PrismaPromise<GetPersonaje_tiene_trabajoAggregateType<T>>

    /**
     * Group by Personaje_tiene_trabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Personaje_tiene_trabajoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Personaje_tiene_trabajoGroupByArgs['orderBy'] }
        : { orderBy?: Personaje_tiene_trabajoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Personaje_tiene_trabajoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaje_tiene_trabajoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Personaje_tiene_trabajo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Personaje_tiene_trabajoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    trabajo<T extends TrabajosArgs= {}>(args?: Subset<T, TrabajosArgs>): Prisma__TrabajosClient<TrabajosGetPayload<T> | Null>;

    personaje<T extends PersonajesArgs= {}>(args?: Subset<T, PersonajesArgs>): Prisma__PersonajesClient<PersonajesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Personaje_tiene_trabajo base type for findUnique actions
   */
  export type Personaje_tiene_trabajoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * Filter, which Personaje_tiene_trabajo to fetch.
     */
    where: Personaje_tiene_trabajoWhereUniqueInput
  }

  /**
   * Personaje_tiene_trabajo findUnique
   */
  export interface Personaje_tiene_trabajoFindUniqueArgs extends Personaje_tiene_trabajoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personaje_tiene_trabajo findUniqueOrThrow
   */
  export type Personaje_tiene_trabajoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * Filter, which Personaje_tiene_trabajo to fetch.
     */
    where: Personaje_tiene_trabajoWhereUniqueInput
  }


  /**
   * Personaje_tiene_trabajo base type for findFirst actions
   */
  export type Personaje_tiene_trabajoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * Filter, which Personaje_tiene_trabajo to fetch.
     */
    where?: Personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personaje_tiene_trabajos.
     */
    cursor?: Personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_tiene_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personaje_tiene_trabajos.
     */
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }

  /**
   * Personaje_tiene_trabajo findFirst
   */
  export interface Personaje_tiene_trabajoFindFirstArgs extends Personaje_tiene_trabajoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personaje_tiene_trabajo findFirstOrThrow
   */
  export type Personaje_tiene_trabajoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * Filter, which Personaje_tiene_trabajo to fetch.
     */
    where?: Personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personaje_tiene_trabajos.
     */
    cursor?: Personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_tiene_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personaje_tiene_trabajos.
     */
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * Personaje_tiene_trabajo findMany
   */
  export type Personaje_tiene_trabajoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * Filter, which Personaje_tiene_trabajos to fetch.
     */
    where?: Personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personaje_tiene_trabajos.
     */
    cursor?: Personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_tiene_trabajos.
     */
    skip?: number
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * Personaje_tiene_trabajo create
   */
  export type Personaje_tiene_trabajoCreateArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * The data needed to create a Personaje_tiene_trabajo.
     */
    data: XOR<Personaje_tiene_trabajoCreateInput, Personaje_tiene_trabajoUncheckedCreateInput>
  }


  /**
   * Personaje_tiene_trabajo createMany
   */
  export type Personaje_tiene_trabajoCreateManyArgs = {
    /**
     * The data used to create many Personaje_tiene_trabajos.
     */
    data: Enumerable<Personaje_tiene_trabajoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Personaje_tiene_trabajo update
   */
  export type Personaje_tiene_trabajoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * The data needed to update a Personaje_tiene_trabajo.
     */
    data: XOR<Personaje_tiene_trabajoUpdateInput, Personaje_tiene_trabajoUncheckedUpdateInput>
    /**
     * Choose, which Personaje_tiene_trabajo to update.
     */
    where: Personaje_tiene_trabajoWhereUniqueInput
  }


  /**
   * Personaje_tiene_trabajo updateMany
   */
  export type Personaje_tiene_trabajoUpdateManyArgs = {
    /**
     * The data used to update Personaje_tiene_trabajos.
     */
    data: XOR<Personaje_tiene_trabajoUpdateManyMutationInput, Personaje_tiene_trabajoUncheckedUpdateManyInput>
    /**
     * Filter which Personaje_tiene_trabajos to update
     */
    where?: Personaje_tiene_trabajoWhereInput
  }


  /**
   * Personaje_tiene_trabajo upsert
   */
  export type Personaje_tiene_trabajoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * The filter to search for the Personaje_tiene_trabajo to update in case it exists.
     */
    where: Personaje_tiene_trabajoWhereUniqueInput
    /**
     * In case the Personaje_tiene_trabajo found by the `where` argument doesn't exist, create a new Personaje_tiene_trabajo with this data.
     */
    create: XOR<Personaje_tiene_trabajoCreateInput, Personaje_tiene_trabajoUncheckedCreateInput>
    /**
     * In case the Personaje_tiene_trabajo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Personaje_tiene_trabajoUpdateInput, Personaje_tiene_trabajoUncheckedUpdateInput>
  }


  /**
   * Personaje_tiene_trabajo delete
   */
  export type Personaje_tiene_trabajoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    /**
     * Filter which Personaje_tiene_trabajo to delete.
     */
    where: Personaje_tiene_trabajoWhereUniqueInput
  }


  /**
   * Personaje_tiene_trabajo deleteMany
   */
  export type Personaje_tiene_trabajoDeleteManyArgs = {
    /**
     * Filter which Personaje_tiene_trabajos to delete
     */
    where?: Personaje_tiene_trabajoWhereInput
  }


  /**
   * Personaje_tiene_trabajo without action
   */
  export type Personaje_tiene_trabajoArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
  }



  /**
   * Model Trabajos
   */


  export type AggregateTrabajos = {
    _count: TrabajosCountAggregateOutputType | null
    _avg: TrabajosAvgAggregateOutputType | null
    _sum: TrabajosSumAggregateOutputType | null
    _min: TrabajosMinAggregateOutputType | null
    _max: TrabajosMaxAggregateOutputType | null
  }

  export type TrabajosAvgAggregateOutputType = {
    id: number | null
    sueldo: number | null
  }

  export type TrabajosSumAggregateOutputType = {
    id: number | null
    sueldo: number | null
  }

  export type TrabajosMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    sueldo: number | null
  }

  export type TrabajosMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    sueldo: number | null
  }

  export type TrabajosCountAggregateOutputType = {
    id: number
    descripcion: number
    sueldo: number
    _all: number
  }


  export type TrabajosAvgAggregateInputType = {
    id?: true
    sueldo?: true
  }

  export type TrabajosSumAggregateInputType = {
    id?: true
    sueldo?: true
  }

  export type TrabajosMinAggregateInputType = {
    id?: true
    descripcion?: true
    sueldo?: true
  }

  export type TrabajosMaxAggregateInputType = {
    id?: true
    descripcion?: true
    sueldo?: true
  }

  export type TrabajosCountAggregateInputType = {
    id?: true
    descripcion?: true
    sueldo?: true
    _all?: true
  }

  export type TrabajosAggregateArgs = {
    /**
     * Filter which Trabajos to aggregate.
     */
    where?: TrabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trabajos to fetch.
     */
    orderBy?: Enumerable<TrabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trabajos
    **/
    _count?: true | TrabajosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrabajosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrabajosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrabajosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrabajosMaxAggregateInputType
  }

  export type GetTrabajosAggregateType<T extends TrabajosAggregateArgs> = {
        [P in keyof T & keyof AggregateTrabajos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrabajos[P]>
      : GetScalarType<T[P], AggregateTrabajos[P]>
  }




  export type TrabajosGroupByArgs = {
    where?: TrabajosWhereInput
    orderBy?: Enumerable<TrabajosOrderByWithAggregationInput>
    by: TrabajosScalarFieldEnum[]
    having?: TrabajosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrabajosCountAggregateInputType | true
    _avg?: TrabajosAvgAggregateInputType
    _sum?: TrabajosSumAggregateInputType
    _min?: TrabajosMinAggregateInputType
    _max?: TrabajosMaxAggregateInputType
  }


  export type TrabajosGroupByOutputType = {
    id: number
    descripcion: string
    sueldo: number
    _count: TrabajosCountAggregateOutputType | null
    _avg: TrabajosAvgAggregateOutputType | null
    _sum: TrabajosSumAggregateOutputType | null
    _min: TrabajosMinAggregateOutputType | null
    _max: TrabajosMaxAggregateOutputType | null
  }

  type GetTrabajosGroupByPayload<T extends TrabajosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TrabajosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrabajosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrabajosGroupByOutputType[P]>
            : GetScalarType<T[P], TrabajosGroupByOutputType[P]>
        }
      >
    >


  export type TrabajosSelect = {
    id?: boolean
    descripcion?: boolean
    sueldo?: boolean
    personaje_tiene_trabajo?: boolean | Trabajos$personaje_tiene_trabajoArgs
    _count?: boolean | TrabajosCountOutputTypeArgs
  }


  export type TrabajosInclude = {
    personaje_tiene_trabajo?: boolean | Trabajos$personaje_tiene_trabajoArgs
    _count?: boolean | TrabajosCountOutputTypeArgs
  }

  export type TrabajosGetPayload<S extends boolean | null | undefined | TrabajosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Trabajos :
    S extends undefined ? never :
    S extends { include: any } & (TrabajosArgs | TrabajosFindManyArgs)
    ? Trabajos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje_tiene_trabajo' ? Array < Personaje_tiene_trabajoGetPayload<S['include'][P]>>  :
        P extends '_count' ? TrabajosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TrabajosArgs | TrabajosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje_tiene_trabajo' ? Array < Personaje_tiene_trabajoGetPayload<S['select'][P]>>  :
        P extends '_count' ? TrabajosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Trabajos ? Trabajos[P] : never
  } 
      : Trabajos


  type TrabajosCountArgs = 
    Omit<TrabajosFindManyArgs, 'select' | 'include'> & {
      select?: TrabajosCountAggregateInputType | true
    }

  export interface TrabajosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Trabajos that matches the filter.
     * @param {TrabajosFindUniqueArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrabajosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrabajosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Trabajos'> extends True ? Prisma__TrabajosClient<TrabajosGetPayload<T>> : Prisma__TrabajosClient<TrabajosGetPayload<T> | null, null>

    /**
     * Find one Trabajos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrabajosFindUniqueOrThrowArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrabajosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TrabajosFindUniqueOrThrowArgs>
    ): Prisma__TrabajosClient<TrabajosGetPayload<T>>

    /**
     * Find the first Trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosFindFirstArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrabajosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrabajosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Trabajos'> extends True ? Prisma__TrabajosClient<TrabajosGetPayload<T>> : Prisma__TrabajosClient<TrabajosGetPayload<T> | null, null>

    /**
     * Find the first Trabajos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosFindFirstOrThrowArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrabajosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TrabajosFindFirstOrThrowArgs>
    ): Prisma__TrabajosClient<TrabajosGetPayload<T>>

    /**
     * Find zero or more Trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trabajos
     * const trabajos = await prisma.trabajos.findMany()
     * 
     * // Get first 10 Trabajos
     * const trabajos = await prisma.trabajos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trabajosWithIdOnly = await prisma.trabajos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrabajosFindManyArgs>(
      args?: SelectSubset<T, TrabajosFindManyArgs>
    ): Prisma.PrismaPromise<Array<TrabajosGetPayload<T>>>

    /**
     * Create a Trabajos.
     * @param {TrabajosCreateArgs} args - Arguments to create a Trabajos.
     * @example
     * // Create one Trabajos
     * const Trabajos = await prisma.trabajos.create({
     *   data: {
     *     // ... data to create a Trabajos
     *   }
     * })
     * 
    **/
    create<T extends TrabajosCreateArgs>(
      args: SelectSubset<T, TrabajosCreateArgs>
    ): Prisma__TrabajosClient<TrabajosGetPayload<T>>

    /**
     * Create many Trabajos.
     *     @param {TrabajosCreateManyArgs} args - Arguments to create many Trabajos.
     *     @example
     *     // Create many Trabajos
     *     const trabajos = await prisma.trabajos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrabajosCreateManyArgs>(
      args?: SelectSubset<T, TrabajosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trabajos.
     * @param {TrabajosDeleteArgs} args - Arguments to delete one Trabajos.
     * @example
     * // Delete one Trabajos
     * const Trabajos = await prisma.trabajos.delete({
     *   where: {
     *     // ... filter to delete one Trabajos
     *   }
     * })
     * 
    **/
    delete<T extends TrabajosDeleteArgs>(
      args: SelectSubset<T, TrabajosDeleteArgs>
    ): Prisma__TrabajosClient<TrabajosGetPayload<T>>

    /**
     * Update one Trabajos.
     * @param {TrabajosUpdateArgs} args - Arguments to update one Trabajos.
     * @example
     * // Update one Trabajos
     * const trabajos = await prisma.trabajos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrabajosUpdateArgs>(
      args: SelectSubset<T, TrabajosUpdateArgs>
    ): Prisma__TrabajosClient<TrabajosGetPayload<T>>

    /**
     * Delete zero or more Trabajos.
     * @param {TrabajosDeleteManyArgs} args - Arguments to filter Trabajos to delete.
     * @example
     * // Delete a few Trabajos
     * const { count } = await prisma.trabajos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrabajosDeleteManyArgs>(
      args?: SelectSubset<T, TrabajosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trabajos
     * const trabajos = await prisma.trabajos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrabajosUpdateManyArgs>(
      args: SelectSubset<T, TrabajosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trabajos.
     * @param {TrabajosUpsertArgs} args - Arguments to update or create a Trabajos.
     * @example
     * // Update or create a Trabajos
     * const trabajos = await prisma.trabajos.upsert({
     *   create: {
     *     // ... data to create a Trabajos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trabajos we want to update
     *   }
     * })
    **/
    upsert<T extends TrabajosUpsertArgs>(
      args: SelectSubset<T, TrabajosUpsertArgs>
    ): Prisma__TrabajosClient<TrabajosGetPayload<T>>

    /**
     * Count the number of Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosCountArgs} args - Arguments to filter Trabajos to count.
     * @example
     * // Count the number of Trabajos
     * const count = await prisma.trabajos.count({
     *   where: {
     *     // ... the filter for the Trabajos we want to count
     *   }
     * })
    **/
    count<T extends TrabajosCountArgs>(
      args?: Subset<T, TrabajosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrabajosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrabajosAggregateArgs>(args: Subset<T, TrabajosAggregateArgs>): Prisma.PrismaPromise<GetTrabajosAggregateType<T>>

    /**
     * Group by Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrabajosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrabajosGroupByArgs['orderBy'] }
        : { orderBy?: TrabajosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrabajosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrabajosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Trabajos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrabajosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje_tiene_trabajo<T extends Trabajos$personaje_tiene_trabajoArgs= {}>(args?: Subset<T, Trabajos$personaje_tiene_trabajoArgs>): Prisma.PrismaPromise<Array<Personaje_tiene_trabajoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Trabajos base type for findUnique actions
   */
  export type TrabajosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * Filter, which Trabajos to fetch.
     */
    where: TrabajosWhereUniqueInput
  }

  /**
   * Trabajos findUnique
   */
  export interface TrabajosFindUniqueArgs extends TrabajosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Trabajos findUniqueOrThrow
   */
  export type TrabajosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * Filter, which Trabajos to fetch.
     */
    where: TrabajosWhereUniqueInput
  }


  /**
   * Trabajos base type for findFirst actions
   */
  export type TrabajosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * Filter, which Trabajos to fetch.
     */
    where?: TrabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trabajos to fetch.
     */
    orderBy?: Enumerable<TrabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trabajos.
     */
    cursor?: TrabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trabajos.
     */
    distinct?: Enumerable<TrabajosScalarFieldEnum>
  }

  /**
   * Trabajos findFirst
   */
  export interface TrabajosFindFirstArgs extends TrabajosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Trabajos findFirstOrThrow
   */
  export type TrabajosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * Filter, which Trabajos to fetch.
     */
    where?: TrabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trabajos to fetch.
     */
    orderBy?: Enumerable<TrabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trabajos.
     */
    cursor?: TrabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trabajos.
     */
    distinct?: Enumerable<TrabajosScalarFieldEnum>
  }


  /**
   * Trabajos findMany
   */
  export type TrabajosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * Filter, which Trabajos to fetch.
     */
    where?: TrabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trabajos to fetch.
     */
    orderBy?: Enumerable<TrabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trabajos.
     */
    cursor?: TrabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trabajos.
     */
    skip?: number
    distinct?: Enumerable<TrabajosScalarFieldEnum>
  }


  /**
   * Trabajos create
   */
  export type TrabajosCreateArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * The data needed to create a Trabajos.
     */
    data: XOR<TrabajosCreateInput, TrabajosUncheckedCreateInput>
  }


  /**
   * Trabajos createMany
   */
  export type TrabajosCreateManyArgs = {
    /**
     * The data used to create many Trabajos.
     */
    data: Enumerable<TrabajosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Trabajos update
   */
  export type TrabajosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * The data needed to update a Trabajos.
     */
    data: XOR<TrabajosUpdateInput, TrabajosUncheckedUpdateInput>
    /**
     * Choose, which Trabajos to update.
     */
    where: TrabajosWhereUniqueInput
  }


  /**
   * Trabajos updateMany
   */
  export type TrabajosUpdateManyArgs = {
    /**
     * The data used to update Trabajos.
     */
    data: XOR<TrabajosUpdateManyMutationInput, TrabajosUncheckedUpdateManyInput>
    /**
     * Filter which Trabajos to update
     */
    where?: TrabajosWhereInput
  }


  /**
   * Trabajos upsert
   */
  export type TrabajosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * The filter to search for the Trabajos to update in case it exists.
     */
    where: TrabajosWhereUniqueInput
    /**
     * In case the Trabajos found by the `where` argument doesn't exist, create a new Trabajos with this data.
     */
    create: XOR<TrabajosCreateInput, TrabajosUncheckedCreateInput>
    /**
     * In case the Trabajos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrabajosUpdateInput, TrabajosUncheckedUpdateInput>
  }


  /**
   * Trabajos delete
   */
  export type TrabajosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
    /**
     * Filter which Trabajos to delete.
     */
    where: TrabajosWhereUniqueInput
  }


  /**
   * Trabajos deleteMany
   */
  export type TrabajosDeleteManyArgs = {
    /**
     * Filter which Trabajos to delete
     */
    where?: TrabajosWhereInput
  }


  /**
   * Trabajos.personaje_tiene_trabajo
   */
  export type Trabajos$personaje_tiene_trabajoArgs = {
    /**
     * Select specific fields to fetch from the Personaje_tiene_trabajo
     */
    select?: Personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_tiene_trabajoInclude | null
    where?: Personaje_tiene_trabajoWhereInput
    orderBy?: Enumerable<Personaje_tiene_trabajoOrderByWithRelationInput>
    cursor?: Personaje_tiene_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * Trabajos without action
   */
  export type TrabajosArgs = {
    /**
     * Select specific fields to fetch from the Trabajos
     */
    select?: TrabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrabajosInclude | null
  }



  /**
   * Model Personaje_habita_reino
   */


  export type AggregatePersonaje_habita_reino = {
    _count: Personaje_habita_reinoCountAggregateOutputType | null
    _avg: Personaje_habita_reinoAvgAggregateOutputType | null
    _sum: Personaje_habita_reinoSumAggregateOutputType | null
    _min: Personaje_habita_reinoMinAggregateOutputType | null
    _max: Personaje_habita_reinoMaxAggregateOutputType | null
  }

  export type Personaje_habita_reinoAvgAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
  }

  export type Personaje_habita_reinoSumAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
  }

  export type Personaje_habita_reinoMinAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
    fecha_registro: Date | null
    es_gobernante: boolean | null
  }

  export type Personaje_habita_reinoMaxAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
    fecha_registro: Date | null
    es_gobernante: boolean | null
  }

  export type Personaje_habita_reinoCountAggregateOutputType = {
    id_personaje: number
    id_reino: number
    fecha_registro: number
    es_gobernante: number
    _all: number
  }


  export type Personaje_habita_reinoAvgAggregateInputType = {
    id_personaje?: true
    id_reino?: true
  }

  export type Personaje_habita_reinoSumAggregateInputType = {
    id_personaje?: true
    id_reino?: true
  }

  export type Personaje_habita_reinoMinAggregateInputType = {
    id_personaje?: true
    id_reino?: true
    fecha_registro?: true
    es_gobernante?: true
  }

  export type Personaje_habita_reinoMaxAggregateInputType = {
    id_personaje?: true
    id_reino?: true
    fecha_registro?: true
    es_gobernante?: true
  }

  export type Personaje_habita_reinoCountAggregateInputType = {
    id_personaje?: true
    id_reino?: true
    fecha_registro?: true
    es_gobernante?: true
    _all?: true
  }

  export type Personaje_habita_reinoAggregateArgs = {
    /**
     * Filter which Personaje_habita_reino to aggregate.
     */
    where?: Personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_habita_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personaje_habita_reinos
    **/
    _count?: true | Personaje_habita_reinoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personaje_habita_reinoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personaje_habita_reinoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personaje_habita_reinoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personaje_habita_reinoMaxAggregateInputType
  }

  export type GetPersonaje_habita_reinoAggregateType<T extends Personaje_habita_reinoAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonaje_habita_reino]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonaje_habita_reino[P]>
      : GetScalarType<T[P], AggregatePersonaje_habita_reino[P]>
  }




  export type Personaje_habita_reinoGroupByArgs = {
    where?: Personaje_habita_reinoWhereInput
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithAggregationInput>
    by: Personaje_habita_reinoScalarFieldEnum[]
    having?: Personaje_habita_reinoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personaje_habita_reinoCountAggregateInputType | true
    _avg?: Personaje_habita_reinoAvgAggregateInputType
    _sum?: Personaje_habita_reinoSumAggregateInputType
    _min?: Personaje_habita_reinoMinAggregateInputType
    _max?: Personaje_habita_reinoMaxAggregateInputType
  }


  export type Personaje_habita_reinoGroupByOutputType = {
    id_personaje: number
    id_reino: number
    fecha_registro: Date
    es_gobernante: boolean
    _count: Personaje_habita_reinoCountAggregateOutputType | null
    _avg: Personaje_habita_reinoAvgAggregateOutputType | null
    _sum: Personaje_habita_reinoSumAggregateOutputType | null
    _min: Personaje_habita_reinoMinAggregateOutputType | null
    _max: Personaje_habita_reinoMaxAggregateOutputType | null
  }

  type GetPersonaje_habita_reinoGroupByPayload<T extends Personaje_habita_reinoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Personaje_habita_reinoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personaje_habita_reinoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personaje_habita_reinoGroupByOutputType[P]>
            : GetScalarType<T[P], Personaje_habita_reinoGroupByOutputType[P]>
        }
      >
    >


  export type Personaje_habita_reinoSelect = {
    id_personaje?: boolean
    id_reino?: boolean
    fecha_registro?: boolean
    es_gobernante?: boolean
    personaje?: boolean | PersonajesArgs
    reino?: boolean | ReinosArgs
  }


  export type Personaje_habita_reinoInclude = {
    personaje?: boolean | PersonajesArgs
    reino?: boolean | ReinosArgs
  }

  export type Personaje_habita_reinoGetPayload<S extends boolean | null | undefined | Personaje_habita_reinoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Personaje_habita_reino :
    S extends undefined ? never :
    S extends { include: any } & (Personaje_habita_reinoArgs | Personaje_habita_reinoFindManyArgs)
    ? Personaje_habita_reino  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje' ? PersonajesGetPayload<S['include'][P]> :
        P extends 'reino' ? ReinosGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Personaje_habita_reinoArgs | Personaje_habita_reinoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje' ? PersonajesGetPayload<S['select'][P]> :
        P extends 'reino' ? ReinosGetPayload<S['select'][P]> :  P extends keyof Personaje_habita_reino ? Personaje_habita_reino[P] : never
  } 
      : Personaje_habita_reino


  type Personaje_habita_reinoCountArgs = 
    Omit<Personaje_habita_reinoFindManyArgs, 'select' | 'include'> & {
      select?: Personaje_habita_reinoCountAggregateInputType | true
    }

  export interface Personaje_habita_reinoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personaje_habita_reino that matches the filter.
     * @param {Personaje_habita_reinoFindUniqueArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Personaje_habita_reinoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Personaje_habita_reinoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personaje_habita_reino'> extends True ? Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>> : Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T> | null, null>

    /**
     * Find one Personaje_habita_reino that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Personaje_habita_reinoFindUniqueOrThrowArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Personaje_habita_reinoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Personaje_habita_reinoFindUniqueOrThrowArgs>
    ): Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>>

    /**
     * Find the first Personaje_habita_reino that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoFindFirstArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Personaje_habita_reinoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Personaje_habita_reinoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personaje_habita_reino'> extends True ? Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>> : Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T> | null, null>

    /**
     * Find the first Personaje_habita_reino that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoFindFirstOrThrowArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Personaje_habita_reinoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Personaje_habita_reinoFindFirstOrThrowArgs>
    ): Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>>

    /**
     * Find zero or more Personaje_habita_reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personaje_habita_reinos
     * const personaje_habita_reinos = await prisma.personaje_habita_reino.findMany()
     * 
     * // Get first 10 Personaje_habita_reinos
     * const personaje_habita_reinos = await prisma.personaje_habita_reino.findMany({ take: 10 })
     * 
     * // Only select the `id_personaje`
     * const personaje_habita_reinoWithId_personajeOnly = await prisma.personaje_habita_reino.findMany({ select: { id_personaje: true } })
     * 
    **/
    findMany<T extends Personaje_habita_reinoFindManyArgs>(
      args?: SelectSubset<T, Personaje_habita_reinoFindManyArgs>
    ): Prisma.PrismaPromise<Array<Personaje_habita_reinoGetPayload<T>>>

    /**
     * Create a Personaje_habita_reino.
     * @param {Personaje_habita_reinoCreateArgs} args - Arguments to create a Personaje_habita_reino.
     * @example
     * // Create one Personaje_habita_reino
     * const Personaje_habita_reino = await prisma.personaje_habita_reino.create({
     *   data: {
     *     // ... data to create a Personaje_habita_reino
     *   }
     * })
     * 
    **/
    create<T extends Personaje_habita_reinoCreateArgs>(
      args: SelectSubset<T, Personaje_habita_reinoCreateArgs>
    ): Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>>

    /**
     * Create many Personaje_habita_reinos.
     *     @param {Personaje_habita_reinoCreateManyArgs} args - Arguments to create many Personaje_habita_reinos.
     *     @example
     *     // Create many Personaje_habita_reinos
     *     const personaje_habita_reino = await prisma.personaje_habita_reino.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Personaje_habita_reinoCreateManyArgs>(
      args?: SelectSubset<T, Personaje_habita_reinoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personaje_habita_reino.
     * @param {Personaje_habita_reinoDeleteArgs} args - Arguments to delete one Personaje_habita_reino.
     * @example
     * // Delete one Personaje_habita_reino
     * const Personaje_habita_reino = await prisma.personaje_habita_reino.delete({
     *   where: {
     *     // ... filter to delete one Personaje_habita_reino
     *   }
     * })
     * 
    **/
    delete<T extends Personaje_habita_reinoDeleteArgs>(
      args: SelectSubset<T, Personaje_habita_reinoDeleteArgs>
    ): Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>>

    /**
     * Update one Personaje_habita_reino.
     * @param {Personaje_habita_reinoUpdateArgs} args - Arguments to update one Personaje_habita_reino.
     * @example
     * // Update one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Personaje_habita_reinoUpdateArgs>(
      args: SelectSubset<T, Personaje_habita_reinoUpdateArgs>
    ): Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>>

    /**
     * Delete zero or more Personaje_habita_reinos.
     * @param {Personaje_habita_reinoDeleteManyArgs} args - Arguments to filter Personaje_habita_reinos to delete.
     * @example
     * // Delete a few Personaje_habita_reinos
     * const { count } = await prisma.personaje_habita_reino.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Personaje_habita_reinoDeleteManyArgs>(
      args?: SelectSubset<T, Personaje_habita_reinoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personaje_habita_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personaje_habita_reinos
     * const personaje_habita_reino = await prisma.personaje_habita_reino.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Personaje_habita_reinoUpdateManyArgs>(
      args: SelectSubset<T, Personaje_habita_reinoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personaje_habita_reino.
     * @param {Personaje_habita_reinoUpsertArgs} args - Arguments to update or create a Personaje_habita_reino.
     * @example
     * // Update or create a Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.upsert({
     *   create: {
     *     // ... data to create a Personaje_habita_reino
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personaje_habita_reino we want to update
     *   }
     * })
    **/
    upsert<T extends Personaje_habita_reinoUpsertArgs>(
      args: SelectSubset<T, Personaje_habita_reinoUpsertArgs>
    ): Prisma__Personaje_habita_reinoClient<Personaje_habita_reinoGetPayload<T>>

    /**
     * Count the number of Personaje_habita_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoCountArgs} args - Arguments to filter Personaje_habita_reinos to count.
     * @example
     * // Count the number of Personaje_habita_reinos
     * const count = await prisma.personaje_habita_reino.count({
     *   where: {
     *     // ... the filter for the Personaje_habita_reinos we want to count
     *   }
     * })
    **/
    count<T extends Personaje_habita_reinoCountArgs>(
      args?: Subset<T, Personaje_habita_reinoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personaje_habita_reinoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personaje_habita_reino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personaje_habita_reinoAggregateArgs>(args: Subset<T, Personaje_habita_reinoAggregateArgs>): Prisma.PrismaPromise<GetPersonaje_habita_reinoAggregateType<T>>

    /**
     * Group by Personaje_habita_reino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Personaje_habita_reinoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Personaje_habita_reinoGroupByArgs['orderBy'] }
        : { orderBy?: Personaje_habita_reinoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Personaje_habita_reinoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaje_habita_reinoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Personaje_habita_reino.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Personaje_habita_reinoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje<T extends PersonajesArgs= {}>(args?: Subset<T, PersonajesArgs>): Prisma__PersonajesClient<PersonajesGetPayload<T> | Null>;

    reino<T extends ReinosArgs= {}>(args?: Subset<T, ReinosArgs>): Prisma__ReinosClient<ReinosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Personaje_habita_reino base type for findUnique actions
   */
  export type Personaje_habita_reinoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * Filter, which Personaje_habita_reino to fetch.
     */
    where: Personaje_habita_reinoWhereUniqueInput
  }

  /**
   * Personaje_habita_reino findUnique
   */
  export interface Personaje_habita_reinoFindUniqueArgs extends Personaje_habita_reinoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personaje_habita_reino findUniqueOrThrow
   */
  export type Personaje_habita_reinoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * Filter, which Personaje_habita_reino to fetch.
     */
    where: Personaje_habita_reinoWhereUniqueInput
  }


  /**
   * Personaje_habita_reino base type for findFirst actions
   */
  export type Personaje_habita_reinoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * Filter, which Personaje_habita_reino to fetch.
     */
    where?: Personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personaje_habita_reinos.
     */
    cursor?: Personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_habita_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personaje_habita_reinos.
     */
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }

  /**
   * Personaje_habita_reino findFirst
   */
  export interface Personaje_habita_reinoFindFirstArgs extends Personaje_habita_reinoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personaje_habita_reino findFirstOrThrow
   */
  export type Personaje_habita_reinoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * Filter, which Personaje_habita_reino to fetch.
     */
    where?: Personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personaje_habita_reinos.
     */
    cursor?: Personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_habita_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personaje_habita_reinos.
     */
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * Personaje_habita_reino findMany
   */
  export type Personaje_habita_reinoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * Filter, which Personaje_habita_reinos to fetch.
     */
    where?: Personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personaje_habita_reinos.
     */
    cursor?: Personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personaje_habita_reinos.
     */
    skip?: number
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * Personaje_habita_reino create
   */
  export type Personaje_habita_reinoCreateArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * The data needed to create a Personaje_habita_reino.
     */
    data: XOR<Personaje_habita_reinoCreateInput, Personaje_habita_reinoUncheckedCreateInput>
  }


  /**
   * Personaje_habita_reino createMany
   */
  export type Personaje_habita_reinoCreateManyArgs = {
    /**
     * The data used to create many Personaje_habita_reinos.
     */
    data: Enumerable<Personaje_habita_reinoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Personaje_habita_reino update
   */
  export type Personaje_habita_reinoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * The data needed to update a Personaje_habita_reino.
     */
    data: XOR<Personaje_habita_reinoUpdateInput, Personaje_habita_reinoUncheckedUpdateInput>
    /**
     * Choose, which Personaje_habita_reino to update.
     */
    where: Personaje_habita_reinoWhereUniqueInput
  }


  /**
   * Personaje_habita_reino updateMany
   */
  export type Personaje_habita_reinoUpdateManyArgs = {
    /**
     * The data used to update Personaje_habita_reinos.
     */
    data: XOR<Personaje_habita_reinoUpdateManyMutationInput, Personaje_habita_reinoUncheckedUpdateManyInput>
    /**
     * Filter which Personaje_habita_reinos to update
     */
    where?: Personaje_habita_reinoWhereInput
  }


  /**
   * Personaje_habita_reino upsert
   */
  export type Personaje_habita_reinoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * The filter to search for the Personaje_habita_reino to update in case it exists.
     */
    where: Personaje_habita_reinoWhereUniqueInput
    /**
     * In case the Personaje_habita_reino found by the `where` argument doesn't exist, create a new Personaje_habita_reino with this data.
     */
    create: XOR<Personaje_habita_reinoCreateInput, Personaje_habita_reinoUncheckedCreateInput>
    /**
     * In case the Personaje_habita_reino was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Personaje_habita_reinoUpdateInput, Personaje_habita_reinoUncheckedUpdateInput>
  }


  /**
   * Personaje_habita_reino delete
   */
  export type Personaje_habita_reinoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    /**
     * Filter which Personaje_habita_reino to delete.
     */
    where: Personaje_habita_reinoWhereUniqueInput
  }


  /**
   * Personaje_habita_reino deleteMany
   */
  export type Personaje_habita_reinoDeleteManyArgs = {
    /**
     * Filter which Personaje_habita_reinos to delete
     */
    where?: Personaje_habita_reinoWhereInput
  }


  /**
   * Personaje_habita_reino without action
   */
  export type Personaje_habita_reinoArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
  }



  /**
   * Model Reinos
   */


  export type AggregateReinos = {
    _count: ReinosCountAggregateOutputType | null
    _avg: ReinosAvgAggregateOutputType | null
    _sum: ReinosSumAggregateOutputType | null
    _min: ReinosMinAggregateOutputType | null
    _max: ReinosMaxAggregateOutputType | null
  }

  export type ReinosAvgAggregateOutputType = {
    id: number | null
    superficie: number | null
  }

  export type ReinosSumAggregateOutputType = {
    id: number | null
    superficie: number | null
  }

  export type ReinosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    ubicacion: string | null
    superficie: number | null
  }

  export type ReinosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    ubicacion: string | null
    superficie: number | null
  }

  export type ReinosCountAggregateOutputType = {
    id: number
    nombre: number
    ubicacion: number
    superficie: number
    _all: number
  }


  export type ReinosAvgAggregateInputType = {
    id?: true
    superficie?: true
  }

  export type ReinosSumAggregateInputType = {
    id?: true
    superficie?: true
  }

  export type ReinosMinAggregateInputType = {
    id?: true
    nombre?: true
    ubicacion?: true
    superficie?: true
  }

  export type ReinosMaxAggregateInputType = {
    id?: true
    nombre?: true
    ubicacion?: true
    superficie?: true
  }

  export type ReinosCountAggregateInputType = {
    id?: true
    nombre?: true
    ubicacion?: true
    superficie?: true
    _all?: true
  }

  export type ReinosAggregateArgs = {
    /**
     * Filter which Reinos to aggregate.
     */
    where?: ReinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reinos to fetch.
     */
    orderBy?: Enumerable<ReinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reinos
    **/
    _count?: true | ReinosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReinosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReinosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReinosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReinosMaxAggregateInputType
  }

  export type GetReinosAggregateType<T extends ReinosAggregateArgs> = {
        [P in keyof T & keyof AggregateReinos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReinos[P]>
      : GetScalarType<T[P], AggregateReinos[P]>
  }




  export type ReinosGroupByArgs = {
    where?: ReinosWhereInput
    orderBy?: Enumerable<ReinosOrderByWithAggregationInput>
    by: ReinosScalarFieldEnum[]
    having?: ReinosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReinosCountAggregateInputType | true
    _avg?: ReinosAvgAggregateInputType
    _sum?: ReinosSumAggregateInputType
    _min?: ReinosMinAggregateInputType
    _max?: ReinosMaxAggregateInputType
  }


  export type ReinosGroupByOutputType = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    _count: ReinosCountAggregateOutputType | null
    _avg: ReinosAvgAggregateOutputType | null
    _sum: ReinosSumAggregateOutputType | null
    _min: ReinosMinAggregateOutputType | null
    _max: ReinosMaxAggregateOutputType | null
  }

  type GetReinosGroupByPayload<T extends ReinosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReinosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReinosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReinosGroupByOutputType[P]>
            : GetScalarType<T[P], ReinosGroupByOutputType[P]>
        }
      >
    >


  export type ReinosSelect = {
    id?: boolean
    nombre?: boolean
    ubicacion?: boolean
    superficie?: boolean
    personaje_habita_reino?: boolean | Reinos$personaje_habita_reinoArgs
    defensas_reinos?: boolean | Reinos$defensas_reinosArgs
    diplomacia1?: boolean | Reinos$diplomacia1Args
    diplomacia2?: boolean | Reinos$diplomacia2Args
    _count?: boolean | ReinosCountOutputTypeArgs
  }


  export type ReinosInclude = {
    personaje_habita_reino?: boolean | Reinos$personaje_habita_reinoArgs
    defensas_reinos?: boolean | Reinos$defensas_reinosArgs
    diplomacia1?: boolean | Reinos$diplomacia1Args
    diplomacia2?: boolean | Reinos$diplomacia2Args
    _count?: boolean | ReinosCountOutputTypeArgs
  }

  export type ReinosGetPayload<S extends boolean | null | undefined | ReinosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Reinos :
    S extends undefined ? never :
    S extends { include: any } & (ReinosArgs | ReinosFindManyArgs)
    ? Reinos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje_habita_reino' ? Array < Personaje_habita_reinoGetPayload<S['include'][P]>>  :
        P extends 'defensas_reinos' ? Array < Defensas_reinosGetPayload<S['include'][P]>>  :
        P extends 'diplomacia1' ? Array < DiplomaciasGetPayload<S['include'][P]>>  :
        P extends 'diplomacia2' ? Array < DiplomaciasGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReinosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReinosArgs | ReinosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje_habita_reino' ? Array < Personaje_habita_reinoGetPayload<S['select'][P]>>  :
        P extends 'defensas_reinos' ? Array < Defensas_reinosGetPayload<S['select'][P]>>  :
        P extends 'diplomacia1' ? Array < DiplomaciasGetPayload<S['select'][P]>>  :
        P extends 'diplomacia2' ? Array < DiplomaciasGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReinosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Reinos ? Reinos[P] : never
  } 
      : Reinos


  type ReinosCountArgs = 
    Omit<ReinosFindManyArgs, 'select' | 'include'> & {
      select?: ReinosCountAggregateInputType | true
    }

  export interface ReinosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reinos that matches the filter.
     * @param {ReinosFindUniqueArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReinosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReinosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reinos'> extends True ? Prisma__ReinosClient<ReinosGetPayload<T>> : Prisma__ReinosClient<ReinosGetPayload<T> | null, null>

    /**
     * Find one Reinos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReinosFindUniqueOrThrowArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReinosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReinosFindUniqueOrThrowArgs>
    ): Prisma__ReinosClient<ReinosGetPayload<T>>

    /**
     * Find the first Reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosFindFirstArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReinosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReinosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reinos'> extends True ? Prisma__ReinosClient<ReinosGetPayload<T>> : Prisma__ReinosClient<ReinosGetPayload<T> | null, null>

    /**
     * Find the first Reinos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosFindFirstOrThrowArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReinosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReinosFindFirstOrThrowArgs>
    ): Prisma__ReinosClient<ReinosGetPayload<T>>

    /**
     * Find zero or more Reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reinos
     * const reinos = await prisma.reinos.findMany()
     * 
     * // Get first 10 Reinos
     * const reinos = await prisma.reinos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reinosWithIdOnly = await prisma.reinos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReinosFindManyArgs>(
      args?: SelectSubset<T, ReinosFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReinosGetPayload<T>>>

    /**
     * Create a Reinos.
     * @param {ReinosCreateArgs} args - Arguments to create a Reinos.
     * @example
     * // Create one Reinos
     * const Reinos = await prisma.reinos.create({
     *   data: {
     *     // ... data to create a Reinos
     *   }
     * })
     * 
    **/
    create<T extends ReinosCreateArgs>(
      args: SelectSubset<T, ReinosCreateArgs>
    ): Prisma__ReinosClient<ReinosGetPayload<T>>

    /**
     * Create many Reinos.
     *     @param {ReinosCreateManyArgs} args - Arguments to create many Reinos.
     *     @example
     *     // Create many Reinos
     *     const reinos = await prisma.reinos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReinosCreateManyArgs>(
      args?: SelectSubset<T, ReinosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reinos.
     * @param {ReinosDeleteArgs} args - Arguments to delete one Reinos.
     * @example
     * // Delete one Reinos
     * const Reinos = await prisma.reinos.delete({
     *   where: {
     *     // ... filter to delete one Reinos
     *   }
     * })
     * 
    **/
    delete<T extends ReinosDeleteArgs>(
      args: SelectSubset<T, ReinosDeleteArgs>
    ): Prisma__ReinosClient<ReinosGetPayload<T>>

    /**
     * Update one Reinos.
     * @param {ReinosUpdateArgs} args - Arguments to update one Reinos.
     * @example
     * // Update one Reinos
     * const reinos = await prisma.reinos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReinosUpdateArgs>(
      args: SelectSubset<T, ReinosUpdateArgs>
    ): Prisma__ReinosClient<ReinosGetPayload<T>>

    /**
     * Delete zero or more Reinos.
     * @param {ReinosDeleteManyArgs} args - Arguments to filter Reinos to delete.
     * @example
     * // Delete a few Reinos
     * const { count } = await prisma.reinos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReinosDeleteManyArgs>(
      args?: SelectSubset<T, ReinosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reinos
     * const reinos = await prisma.reinos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReinosUpdateManyArgs>(
      args: SelectSubset<T, ReinosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reinos.
     * @param {ReinosUpsertArgs} args - Arguments to update or create a Reinos.
     * @example
     * // Update or create a Reinos
     * const reinos = await prisma.reinos.upsert({
     *   create: {
     *     // ... data to create a Reinos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reinos we want to update
     *   }
     * })
    **/
    upsert<T extends ReinosUpsertArgs>(
      args: SelectSubset<T, ReinosUpsertArgs>
    ): Prisma__ReinosClient<ReinosGetPayload<T>>

    /**
     * Count the number of Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosCountArgs} args - Arguments to filter Reinos to count.
     * @example
     * // Count the number of Reinos
     * const count = await prisma.reinos.count({
     *   where: {
     *     // ... the filter for the Reinos we want to count
     *   }
     * })
    **/
    count<T extends ReinosCountArgs>(
      args?: Subset<T, ReinosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReinosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReinosAggregateArgs>(args: Subset<T, ReinosAggregateArgs>): Prisma.PrismaPromise<GetReinosAggregateType<T>>

    /**
     * Group by Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReinosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReinosGroupByArgs['orderBy'] }
        : { orderBy?: ReinosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReinosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReinosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reinos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReinosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje_habita_reino<T extends Reinos$personaje_habita_reinoArgs= {}>(args?: Subset<T, Reinos$personaje_habita_reinoArgs>): Prisma.PrismaPromise<Array<Personaje_habita_reinoGetPayload<T>>| Null>;

    defensas_reinos<T extends Reinos$defensas_reinosArgs= {}>(args?: Subset<T, Reinos$defensas_reinosArgs>): Prisma.PrismaPromise<Array<Defensas_reinosGetPayload<T>>| Null>;

    diplomacia1<T extends Reinos$diplomacia1Args= {}>(args?: Subset<T, Reinos$diplomacia1Args>): Prisma.PrismaPromise<Array<DiplomaciasGetPayload<T>>| Null>;

    diplomacia2<T extends Reinos$diplomacia2Args= {}>(args?: Subset<T, Reinos$diplomacia2Args>): Prisma.PrismaPromise<Array<DiplomaciasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reinos base type for findUnique actions
   */
  export type ReinosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * Filter, which Reinos to fetch.
     */
    where: ReinosWhereUniqueInput
  }

  /**
   * Reinos findUnique
   */
  export interface ReinosFindUniqueArgs extends ReinosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reinos findUniqueOrThrow
   */
  export type ReinosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * Filter, which Reinos to fetch.
     */
    where: ReinosWhereUniqueInput
  }


  /**
   * Reinos base type for findFirst actions
   */
  export type ReinosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * Filter, which Reinos to fetch.
     */
    where?: ReinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reinos to fetch.
     */
    orderBy?: Enumerable<ReinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reinos.
     */
    cursor?: ReinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reinos.
     */
    distinct?: Enumerable<ReinosScalarFieldEnum>
  }

  /**
   * Reinos findFirst
   */
  export interface ReinosFindFirstArgs extends ReinosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reinos findFirstOrThrow
   */
  export type ReinosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * Filter, which Reinos to fetch.
     */
    where?: ReinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reinos to fetch.
     */
    orderBy?: Enumerable<ReinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reinos.
     */
    cursor?: ReinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reinos.
     */
    distinct?: Enumerable<ReinosScalarFieldEnum>
  }


  /**
   * Reinos findMany
   */
  export type ReinosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * Filter, which Reinos to fetch.
     */
    where?: ReinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reinos to fetch.
     */
    orderBy?: Enumerable<ReinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reinos.
     */
    cursor?: ReinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reinos.
     */
    skip?: number
    distinct?: Enumerable<ReinosScalarFieldEnum>
  }


  /**
   * Reinos create
   */
  export type ReinosCreateArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * The data needed to create a Reinos.
     */
    data: XOR<ReinosCreateInput, ReinosUncheckedCreateInput>
  }


  /**
   * Reinos createMany
   */
  export type ReinosCreateManyArgs = {
    /**
     * The data used to create many Reinos.
     */
    data: Enumerable<ReinosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reinos update
   */
  export type ReinosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * The data needed to update a Reinos.
     */
    data: XOR<ReinosUpdateInput, ReinosUncheckedUpdateInput>
    /**
     * Choose, which Reinos to update.
     */
    where: ReinosWhereUniqueInput
  }


  /**
   * Reinos updateMany
   */
  export type ReinosUpdateManyArgs = {
    /**
     * The data used to update Reinos.
     */
    data: XOR<ReinosUpdateManyMutationInput, ReinosUncheckedUpdateManyInput>
    /**
     * Filter which Reinos to update
     */
    where?: ReinosWhereInput
  }


  /**
   * Reinos upsert
   */
  export type ReinosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * The filter to search for the Reinos to update in case it exists.
     */
    where: ReinosWhereUniqueInput
    /**
     * In case the Reinos found by the `where` argument doesn't exist, create a new Reinos with this data.
     */
    create: XOR<ReinosCreateInput, ReinosUncheckedCreateInput>
    /**
     * In case the Reinos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReinosUpdateInput, ReinosUncheckedUpdateInput>
  }


  /**
   * Reinos delete
   */
  export type ReinosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
    /**
     * Filter which Reinos to delete.
     */
    where: ReinosWhereUniqueInput
  }


  /**
   * Reinos deleteMany
   */
  export type ReinosDeleteManyArgs = {
    /**
     * Filter which Reinos to delete
     */
    where?: ReinosWhereInput
  }


  /**
   * Reinos.personaje_habita_reino
   */
  export type Reinos$personaje_habita_reinoArgs = {
    /**
     * Select specific fields to fetch from the Personaje_habita_reino
     */
    select?: Personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Personaje_habita_reinoInclude | null
    where?: Personaje_habita_reinoWhereInput
    orderBy?: Enumerable<Personaje_habita_reinoOrderByWithRelationInput>
    cursor?: Personaje_habita_reinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * Reinos.defensas_reinos
   */
  export type Reinos$defensas_reinosArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    where?: Defensas_reinosWhereInput
    orderBy?: Enumerable<Defensas_reinosOrderByWithRelationInput>
    cursor?: Defensas_reinosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Defensas_reinosScalarFieldEnum>
  }


  /**
   * Reinos.diplomacia1
   */
  export type Reinos$diplomacia1Args = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    where?: DiplomaciasWhereInput
    orderBy?: Enumerable<DiplomaciasOrderByWithRelationInput>
    cursor?: DiplomaciasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * Reinos.diplomacia2
   */
  export type Reinos$diplomacia2Args = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    where?: DiplomaciasWhereInput
    orderBy?: Enumerable<DiplomaciasOrderByWithRelationInput>
    cursor?: DiplomaciasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * Reinos without action
   */
  export type ReinosArgs = {
    /**
     * Select specific fields to fetch from the Reinos
     */
    select?: ReinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReinosInclude | null
  }



  /**
   * Model Defensas_reinos
   */


  export type AggregateDefensas_reinos = {
    _count: Defensas_reinosCountAggregateOutputType | null
    _avg: Defensas_reinosAvgAggregateOutputType | null
    _sum: Defensas_reinosSumAggregateOutputType | null
    _min: Defensas_reinosMinAggregateOutputType | null
    _max: Defensas_reinosMaxAggregateOutputType | null
  }

  export type Defensas_reinosAvgAggregateOutputType = {
    id_reinos: number | null
    id_defensas: number | null
  }

  export type Defensas_reinosSumAggregateOutputType = {
    id_reinos: number | null
    id_defensas: number | null
  }

  export type Defensas_reinosMinAggregateOutputType = {
    id_reinos: number | null
    id_defensas: number | null
  }

  export type Defensas_reinosMaxAggregateOutputType = {
    id_reinos: number | null
    id_defensas: number | null
  }

  export type Defensas_reinosCountAggregateOutputType = {
    id_reinos: number
    id_defensas: number
    _all: number
  }


  export type Defensas_reinosAvgAggregateInputType = {
    id_reinos?: true
    id_defensas?: true
  }

  export type Defensas_reinosSumAggregateInputType = {
    id_reinos?: true
    id_defensas?: true
  }

  export type Defensas_reinosMinAggregateInputType = {
    id_reinos?: true
    id_defensas?: true
  }

  export type Defensas_reinosMaxAggregateInputType = {
    id_reinos?: true
    id_defensas?: true
  }

  export type Defensas_reinosCountAggregateInputType = {
    id_reinos?: true
    id_defensas?: true
    _all?: true
  }

  export type Defensas_reinosAggregateArgs = {
    /**
     * Filter which Defensas_reinos to aggregate.
     */
    where?: Defensas_reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas_reinos to fetch.
     */
    orderBy?: Enumerable<Defensas_reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Defensas_reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Defensas_reinos
    **/
    _count?: true | Defensas_reinosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Defensas_reinosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Defensas_reinosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Defensas_reinosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Defensas_reinosMaxAggregateInputType
  }

  export type GetDefensas_reinosAggregateType<T extends Defensas_reinosAggregateArgs> = {
        [P in keyof T & keyof AggregateDefensas_reinos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefensas_reinos[P]>
      : GetScalarType<T[P], AggregateDefensas_reinos[P]>
  }




  export type Defensas_reinosGroupByArgs = {
    where?: Defensas_reinosWhereInput
    orderBy?: Enumerable<Defensas_reinosOrderByWithAggregationInput>
    by: Defensas_reinosScalarFieldEnum[]
    having?: Defensas_reinosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Defensas_reinosCountAggregateInputType | true
    _avg?: Defensas_reinosAvgAggregateInputType
    _sum?: Defensas_reinosSumAggregateInputType
    _min?: Defensas_reinosMinAggregateInputType
    _max?: Defensas_reinosMaxAggregateInputType
  }


  export type Defensas_reinosGroupByOutputType = {
    id_reinos: number
    id_defensas: number
    _count: Defensas_reinosCountAggregateOutputType | null
    _avg: Defensas_reinosAvgAggregateOutputType | null
    _sum: Defensas_reinosSumAggregateOutputType | null
    _min: Defensas_reinosMinAggregateOutputType | null
    _max: Defensas_reinosMaxAggregateOutputType | null
  }

  type GetDefensas_reinosGroupByPayload<T extends Defensas_reinosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Defensas_reinosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Defensas_reinosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Defensas_reinosGroupByOutputType[P]>
            : GetScalarType<T[P], Defensas_reinosGroupByOutputType[P]>
        }
      >
    >


  export type Defensas_reinosSelect = {
    id_reinos?: boolean
    id_defensas?: boolean
    reino?: boolean | ReinosArgs
    defensa?: boolean | DefensasArgs
  }


  export type Defensas_reinosInclude = {
    reino?: boolean | ReinosArgs
    defensa?: boolean | DefensasArgs
  }

  export type Defensas_reinosGetPayload<S extends boolean | null | undefined | Defensas_reinosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Defensas_reinos :
    S extends undefined ? never :
    S extends { include: any } & (Defensas_reinosArgs | Defensas_reinosFindManyArgs)
    ? Defensas_reinos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reino' ? ReinosGetPayload<S['include'][P]> :
        P extends 'defensa' ? DefensasGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Defensas_reinosArgs | Defensas_reinosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reino' ? ReinosGetPayload<S['select'][P]> :
        P extends 'defensa' ? DefensasGetPayload<S['select'][P]> :  P extends keyof Defensas_reinos ? Defensas_reinos[P] : never
  } 
      : Defensas_reinos


  type Defensas_reinosCountArgs = 
    Omit<Defensas_reinosFindManyArgs, 'select' | 'include'> & {
      select?: Defensas_reinosCountAggregateInputType | true
    }

  export interface Defensas_reinosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Defensas_reinos that matches the filter.
     * @param {Defensas_reinosFindUniqueArgs} args - Arguments to find a Defensas_reinos
     * @example
     * // Get one Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Defensas_reinosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Defensas_reinosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Defensas_reinos'> extends True ? Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>> : Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T> | null, null>

    /**
     * Find one Defensas_reinos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Defensas_reinosFindUniqueOrThrowArgs} args - Arguments to find a Defensas_reinos
     * @example
     * // Get one Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Defensas_reinosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Defensas_reinosFindUniqueOrThrowArgs>
    ): Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>>

    /**
     * Find the first Defensas_reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosFindFirstArgs} args - Arguments to find a Defensas_reinos
     * @example
     * // Get one Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Defensas_reinosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Defensas_reinosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Defensas_reinos'> extends True ? Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>> : Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T> | null, null>

    /**
     * Find the first Defensas_reinos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosFindFirstOrThrowArgs} args - Arguments to find a Defensas_reinos
     * @example
     * // Get one Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Defensas_reinosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Defensas_reinosFindFirstOrThrowArgs>
    ): Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>>

    /**
     * Find zero or more Defensas_reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.findMany()
     * 
     * // Get first 10 Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.findMany({ take: 10 })
     * 
     * // Only select the `id_reinos`
     * const defensas_reinosWithId_reinosOnly = await prisma.defensas_reinos.findMany({ select: { id_reinos: true } })
     * 
    **/
    findMany<T extends Defensas_reinosFindManyArgs>(
      args?: SelectSubset<T, Defensas_reinosFindManyArgs>
    ): Prisma.PrismaPromise<Array<Defensas_reinosGetPayload<T>>>

    /**
     * Create a Defensas_reinos.
     * @param {Defensas_reinosCreateArgs} args - Arguments to create a Defensas_reinos.
     * @example
     * // Create one Defensas_reinos
     * const Defensas_reinos = await prisma.defensas_reinos.create({
     *   data: {
     *     // ... data to create a Defensas_reinos
     *   }
     * })
     * 
    **/
    create<T extends Defensas_reinosCreateArgs>(
      args: SelectSubset<T, Defensas_reinosCreateArgs>
    ): Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>>

    /**
     * Create many Defensas_reinos.
     *     @param {Defensas_reinosCreateManyArgs} args - Arguments to create many Defensas_reinos.
     *     @example
     *     // Create many Defensas_reinos
     *     const defensas_reinos = await prisma.defensas_reinos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Defensas_reinosCreateManyArgs>(
      args?: SelectSubset<T, Defensas_reinosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Defensas_reinos.
     * @param {Defensas_reinosDeleteArgs} args - Arguments to delete one Defensas_reinos.
     * @example
     * // Delete one Defensas_reinos
     * const Defensas_reinos = await prisma.defensas_reinos.delete({
     *   where: {
     *     // ... filter to delete one Defensas_reinos
     *   }
     * })
     * 
    **/
    delete<T extends Defensas_reinosDeleteArgs>(
      args: SelectSubset<T, Defensas_reinosDeleteArgs>
    ): Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>>

    /**
     * Update one Defensas_reinos.
     * @param {Defensas_reinosUpdateArgs} args - Arguments to update one Defensas_reinos.
     * @example
     * // Update one Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Defensas_reinosUpdateArgs>(
      args: SelectSubset<T, Defensas_reinosUpdateArgs>
    ): Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>>

    /**
     * Delete zero or more Defensas_reinos.
     * @param {Defensas_reinosDeleteManyArgs} args - Arguments to filter Defensas_reinos to delete.
     * @example
     * // Delete a few Defensas_reinos
     * const { count } = await prisma.defensas_reinos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Defensas_reinosDeleteManyArgs>(
      args?: SelectSubset<T, Defensas_reinosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defensas_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Defensas_reinosUpdateManyArgs>(
      args: SelectSubset<T, Defensas_reinosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defensas_reinos.
     * @param {Defensas_reinosUpsertArgs} args - Arguments to update or create a Defensas_reinos.
     * @example
     * // Update or create a Defensas_reinos
     * const defensas_reinos = await prisma.defensas_reinos.upsert({
     *   create: {
     *     // ... data to create a Defensas_reinos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defensas_reinos we want to update
     *   }
     * })
    **/
    upsert<T extends Defensas_reinosUpsertArgs>(
      args: SelectSubset<T, Defensas_reinosUpsertArgs>
    ): Prisma__Defensas_reinosClient<Defensas_reinosGetPayload<T>>

    /**
     * Count the number of Defensas_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosCountArgs} args - Arguments to filter Defensas_reinos to count.
     * @example
     * // Count the number of Defensas_reinos
     * const count = await prisma.defensas_reinos.count({
     *   where: {
     *     // ... the filter for the Defensas_reinos we want to count
     *   }
     * })
    **/
    count<T extends Defensas_reinosCountArgs>(
      args?: Subset<T, Defensas_reinosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Defensas_reinosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defensas_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Defensas_reinosAggregateArgs>(args: Subset<T, Defensas_reinosAggregateArgs>): Prisma.PrismaPromise<GetDefensas_reinosAggregateType<T>>

    /**
     * Group by Defensas_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defensas_reinosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Defensas_reinosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Defensas_reinosGroupByArgs['orderBy'] }
        : { orderBy?: Defensas_reinosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Defensas_reinosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefensas_reinosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Defensas_reinos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Defensas_reinosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reino<T extends ReinosArgs= {}>(args?: Subset<T, ReinosArgs>): Prisma__ReinosClient<ReinosGetPayload<T> | Null>;

    defensa<T extends DefensasArgs= {}>(args?: Subset<T, DefensasArgs>): Prisma__DefensasClient<DefensasGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Defensas_reinos base type for findUnique actions
   */
  export type Defensas_reinosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * Filter, which Defensas_reinos to fetch.
     */
    where: Defensas_reinosWhereUniqueInput
  }

  /**
   * Defensas_reinos findUnique
   */
  export interface Defensas_reinosFindUniqueArgs extends Defensas_reinosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Defensas_reinos findUniqueOrThrow
   */
  export type Defensas_reinosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * Filter, which Defensas_reinos to fetch.
     */
    where: Defensas_reinosWhereUniqueInput
  }


  /**
   * Defensas_reinos base type for findFirst actions
   */
  export type Defensas_reinosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * Filter, which Defensas_reinos to fetch.
     */
    where?: Defensas_reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas_reinos to fetch.
     */
    orderBy?: Enumerable<Defensas_reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defensas_reinos.
     */
    cursor?: Defensas_reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defensas_reinos.
     */
    distinct?: Enumerable<Defensas_reinosScalarFieldEnum>
  }

  /**
   * Defensas_reinos findFirst
   */
  export interface Defensas_reinosFindFirstArgs extends Defensas_reinosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Defensas_reinos findFirstOrThrow
   */
  export type Defensas_reinosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * Filter, which Defensas_reinos to fetch.
     */
    where?: Defensas_reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas_reinos to fetch.
     */
    orderBy?: Enumerable<Defensas_reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defensas_reinos.
     */
    cursor?: Defensas_reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defensas_reinos.
     */
    distinct?: Enumerable<Defensas_reinosScalarFieldEnum>
  }


  /**
   * Defensas_reinos findMany
   */
  export type Defensas_reinosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * Filter, which Defensas_reinos to fetch.
     */
    where?: Defensas_reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas_reinos to fetch.
     */
    orderBy?: Enumerable<Defensas_reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Defensas_reinos.
     */
    cursor?: Defensas_reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas_reinos.
     */
    skip?: number
    distinct?: Enumerable<Defensas_reinosScalarFieldEnum>
  }


  /**
   * Defensas_reinos create
   */
  export type Defensas_reinosCreateArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * The data needed to create a Defensas_reinos.
     */
    data: XOR<Defensas_reinosCreateInput, Defensas_reinosUncheckedCreateInput>
  }


  /**
   * Defensas_reinos createMany
   */
  export type Defensas_reinosCreateManyArgs = {
    /**
     * The data used to create many Defensas_reinos.
     */
    data: Enumerable<Defensas_reinosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Defensas_reinos update
   */
  export type Defensas_reinosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * The data needed to update a Defensas_reinos.
     */
    data: XOR<Defensas_reinosUpdateInput, Defensas_reinosUncheckedUpdateInput>
    /**
     * Choose, which Defensas_reinos to update.
     */
    where: Defensas_reinosWhereUniqueInput
  }


  /**
   * Defensas_reinos updateMany
   */
  export type Defensas_reinosUpdateManyArgs = {
    /**
     * The data used to update Defensas_reinos.
     */
    data: XOR<Defensas_reinosUpdateManyMutationInput, Defensas_reinosUncheckedUpdateManyInput>
    /**
     * Filter which Defensas_reinos to update
     */
    where?: Defensas_reinosWhereInput
  }


  /**
   * Defensas_reinos upsert
   */
  export type Defensas_reinosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * The filter to search for the Defensas_reinos to update in case it exists.
     */
    where: Defensas_reinosWhereUniqueInput
    /**
     * In case the Defensas_reinos found by the `where` argument doesn't exist, create a new Defensas_reinos with this data.
     */
    create: XOR<Defensas_reinosCreateInput, Defensas_reinosUncheckedCreateInput>
    /**
     * In case the Defensas_reinos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Defensas_reinosUpdateInput, Defensas_reinosUncheckedUpdateInput>
  }


  /**
   * Defensas_reinos delete
   */
  export type Defensas_reinosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    /**
     * Filter which Defensas_reinos to delete.
     */
    where: Defensas_reinosWhereUniqueInput
  }


  /**
   * Defensas_reinos deleteMany
   */
  export type Defensas_reinosDeleteManyArgs = {
    /**
     * Filter which Defensas_reinos to delete
     */
    where?: Defensas_reinosWhereInput
  }


  /**
   * Defensas_reinos without action
   */
  export type Defensas_reinosArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
  }



  /**
   * Model Defensas
   */


  export type AggregateDefensas = {
    _count: DefensasCountAggregateOutputType | null
    _avg: DefensasAvgAggregateOutputType | null
    _sum: DefensasSumAggregateOutputType | null
    _min: DefensasMinAggregateOutputType | null
    _max: DefensasMaxAggregateOutputType | null
  }

  export type DefensasAvgAggregateOutputType = {
    id: number | null
  }

  export type DefensasSumAggregateOutputType = {
    id: number | null
  }

  export type DefensasMinAggregateOutputType = {
    id: number | null
    defensa: string | null
  }

  export type DefensasMaxAggregateOutputType = {
    id: number | null
    defensa: string | null
  }

  export type DefensasCountAggregateOutputType = {
    id: number
    defensa: number
    _all: number
  }


  export type DefensasAvgAggregateInputType = {
    id?: true
  }

  export type DefensasSumAggregateInputType = {
    id?: true
  }

  export type DefensasMinAggregateInputType = {
    id?: true
    defensa?: true
  }

  export type DefensasMaxAggregateInputType = {
    id?: true
    defensa?: true
  }

  export type DefensasCountAggregateInputType = {
    id?: true
    defensa?: true
    _all?: true
  }

  export type DefensasAggregateArgs = {
    /**
     * Filter which Defensas to aggregate.
     */
    where?: DefensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas to fetch.
     */
    orderBy?: Enumerable<DefensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Defensas
    **/
    _count?: true | DefensasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefensasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefensasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefensasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefensasMaxAggregateInputType
  }

  export type GetDefensasAggregateType<T extends DefensasAggregateArgs> = {
        [P in keyof T & keyof AggregateDefensas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefensas[P]>
      : GetScalarType<T[P], AggregateDefensas[P]>
  }




  export type DefensasGroupByArgs = {
    where?: DefensasWhereInput
    orderBy?: Enumerable<DefensasOrderByWithAggregationInput>
    by: DefensasScalarFieldEnum[]
    having?: DefensasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefensasCountAggregateInputType | true
    _avg?: DefensasAvgAggregateInputType
    _sum?: DefensasSumAggregateInputType
    _min?: DefensasMinAggregateInputType
    _max?: DefensasMaxAggregateInputType
  }


  export type DefensasGroupByOutputType = {
    id: number
    defensa: string
    _count: DefensasCountAggregateOutputType | null
    _avg: DefensasAvgAggregateOutputType | null
    _sum: DefensasSumAggregateOutputType | null
    _min: DefensasMinAggregateOutputType | null
    _max: DefensasMaxAggregateOutputType | null
  }

  type GetDefensasGroupByPayload<T extends DefensasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DefensasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefensasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefensasGroupByOutputType[P]>
            : GetScalarType<T[P], DefensasGroupByOutputType[P]>
        }
      >
    >


  export type DefensasSelect = {
    id?: boolean
    defensa?: boolean
    defensas_reinos?: boolean | Defensas$defensas_reinosArgs
    _count?: boolean | DefensasCountOutputTypeArgs
  }


  export type DefensasInclude = {
    defensas_reinos?: boolean | Defensas$defensas_reinosArgs
    _count?: boolean | DefensasCountOutputTypeArgs
  }

  export type DefensasGetPayload<S extends boolean | null | undefined | DefensasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Defensas :
    S extends undefined ? never :
    S extends { include: any } & (DefensasArgs | DefensasFindManyArgs)
    ? Defensas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'defensas_reinos' ? Array < Defensas_reinosGetPayload<S['include'][P]>>  :
        P extends '_count' ? DefensasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DefensasArgs | DefensasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'defensas_reinos' ? Array < Defensas_reinosGetPayload<S['select'][P]>>  :
        P extends '_count' ? DefensasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Defensas ? Defensas[P] : never
  } 
      : Defensas


  type DefensasCountArgs = 
    Omit<DefensasFindManyArgs, 'select' | 'include'> & {
      select?: DefensasCountAggregateInputType | true
    }

  export interface DefensasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Defensas that matches the filter.
     * @param {DefensasFindUniqueArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DefensasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DefensasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Defensas'> extends True ? Prisma__DefensasClient<DefensasGetPayload<T>> : Prisma__DefensasClient<DefensasGetPayload<T> | null, null>

    /**
     * Find one Defensas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DefensasFindUniqueOrThrowArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DefensasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DefensasFindUniqueOrThrowArgs>
    ): Prisma__DefensasClient<DefensasGetPayload<T>>

    /**
     * Find the first Defensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasFindFirstArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DefensasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DefensasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Defensas'> extends True ? Prisma__DefensasClient<DefensasGetPayload<T>> : Prisma__DefensasClient<DefensasGetPayload<T> | null, null>

    /**
     * Find the first Defensas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasFindFirstOrThrowArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DefensasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DefensasFindFirstOrThrowArgs>
    ): Prisma__DefensasClient<DefensasGetPayload<T>>

    /**
     * Find zero or more Defensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defensas
     * const defensas = await prisma.defensas.findMany()
     * 
     * // Get first 10 Defensas
     * const defensas = await prisma.defensas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defensasWithIdOnly = await prisma.defensas.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DefensasFindManyArgs>(
      args?: SelectSubset<T, DefensasFindManyArgs>
    ): Prisma.PrismaPromise<Array<DefensasGetPayload<T>>>

    /**
     * Create a Defensas.
     * @param {DefensasCreateArgs} args - Arguments to create a Defensas.
     * @example
     * // Create one Defensas
     * const Defensas = await prisma.defensas.create({
     *   data: {
     *     // ... data to create a Defensas
     *   }
     * })
     * 
    **/
    create<T extends DefensasCreateArgs>(
      args: SelectSubset<T, DefensasCreateArgs>
    ): Prisma__DefensasClient<DefensasGetPayload<T>>

    /**
     * Create many Defensas.
     *     @param {DefensasCreateManyArgs} args - Arguments to create many Defensas.
     *     @example
     *     // Create many Defensas
     *     const defensas = await prisma.defensas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DefensasCreateManyArgs>(
      args?: SelectSubset<T, DefensasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Defensas.
     * @param {DefensasDeleteArgs} args - Arguments to delete one Defensas.
     * @example
     * // Delete one Defensas
     * const Defensas = await prisma.defensas.delete({
     *   where: {
     *     // ... filter to delete one Defensas
     *   }
     * })
     * 
    **/
    delete<T extends DefensasDeleteArgs>(
      args: SelectSubset<T, DefensasDeleteArgs>
    ): Prisma__DefensasClient<DefensasGetPayload<T>>

    /**
     * Update one Defensas.
     * @param {DefensasUpdateArgs} args - Arguments to update one Defensas.
     * @example
     * // Update one Defensas
     * const defensas = await prisma.defensas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DefensasUpdateArgs>(
      args: SelectSubset<T, DefensasUpdateArgs>
    ): Prisma__DefensasClient<DefensasGetPayload<T>>

    /**
     * Delete zero or more Defensas.
     * @param {DefensasDeleteManyArgs} args - Arguments to filter Defensas to delete.
     * @example
     * // Delete a few Defensas
     * const { count } = await prisma.defensas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DefensasDeleteManyArgs>(
      args?: SelectSubset<T, DefensasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defensas
     * const defensas = await prisma.defensas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DefensasUpdateManyArgs>(
      args: SelectSubset<T, DefensasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defensas.
     * @param {DefensasUpsertArgs} args - Arguments to update or create a Defensas.
     * @example
     * // Update or create a Defensas
     * const defensas = await prisma.defensas.upsert({
     *   create: {
     *     // ... data to create a Defensas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defensas we want to update
     *   }
     * })
    **/
    upsert<T extends DefensasUpsertArgs>(
      args: SelectSubset<T, DefensasUpsertArgs>
    ): Prisma__DefensasClient<DefensasGetPayload<T>>

    /**
     * Count the number of Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasCountArgs} args - Arguments to filter Defensas to count.
     * @example
     * // Count the number of Defensas
     * const count = await prisma.defensas.count({
     *   where: {
     *     // ... the filter for the Defensas we want to count
     *   }
     * })
    **/
    count<T extends DefensasCountArgs>(
      args?: Subset<T, DefensasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefensasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefensasAggregateArgs>(args: Subset<T, DefensasAggregateArgs>): Prisma.PrismaPromise<GetDefensasAggregateType<T>>

    /**
     * Group by Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefensasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefensasGroupByArgs['orderBy'] }
        : { orderBy?: DefensasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefensasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefensasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Defensas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DefensasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    defensas_reinos<T extends Defensas$defensas_reinosArgs= {}>(args?: Subset<T, Defensas$defensas_reinosArgs>): Prisma.PrismaPromise<Array<Defensas_reinosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Defensas base type for findUnique actions
   */
  export type DefensasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * Filter, which Defensas to fetch.
     */
    where: DefensasWhereUniqueInput
  }

  /**
   * Defensas findUnique
   */
  export interface DefensasFindUniqueArgs extends DefensasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Defensas findUniqueOrThrow
   */
  export type DefensasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * Filter, which Defensas to fetch.
     */
    where: DefensasWhereUniqueInput
  }


  /**
   * Defensas base type for findFirst actions
   */
  export type DefensasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * Filter, which Defensas to fetch.
     */
    where?: DefensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas to fetch.
     */
    orderBy?: Enumerable<DefensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defensas.
     */
    cursor?: DefensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defensas.
     */
    distinct?: Enumerable<DefensasScalarFieldEnum>
  }

  /**
   * Defensas findFirst
   */
  export interface DefensasFindFirstArgs extends DefensasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Defensas findFirstOrThrow
   */
  export type DefensasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * Filter, which Defensas to fetch.
     */
    where?: DefensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas to fetch.
     */
    orderBy?: Enumerable<DefensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defensas.
     */
    cursor?: DefensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defensas.
     */
    distinct?: Enumerable<DefensasScalarFieldEnum>
  }


  /**
   * Defensas findMany
   */
  export type DefensasFindManyArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * Filter, which Defensas to fetch.
     */
    where?: DefensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defensas to fetch.
     */
    orderBy?: Enumerable<DefensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Defensas.
     */
    cursor?: DefensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defensas.
     */
    skip?: number
    distinct?: Enumerable<DefensasScalarFieldEnum>
  }


  /**
   * Defensas create
   */
  export type DefensasCreateArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * The data needed to create a Defensas.
     */
    data: XOR<DefensasCreateInput, DefensasUncheckedCreateInput>
  }


  /**
   * Defensas createMany
   */
  export type DefensasCreateManyArgs = {
    /**
     * The data used to create many Defensas.
     */
    data: Enumerable<DefensasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Defensas update
   */
  export type DefensasUpdateArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * The data needed to update a Defensas.
     */
    data: XOR<DefensasUpdateInput, DefensasUncheckedUpdateInput>
    /**
     * Choose, which Defensas to update.
     */
    where: DefensasWhereUniqueInput
  }


  /**
   * Defensas updateMany
   */
  export type DefensasUpdateManyArgs = {
    /**
     * The data used to update Defensas.
     */
    data: XOR<DefensasUpdateManyMutationInput, DefensasUncheckedUpdateManyInput>
    /**
     * Filter which Defensas to update
     */
    where?: DefensasWhereInput
  }


  /**
   * Defensas upsert
   */
  export type DefensasUpsertArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * The filter to search for the Defensas to update in case it exists.
     */
    where: DefensasWhereUniqueInput
    /**
     * In case the Defensas found by the `where` argument doesn't exist, create a new Defensas with this data.
     */
    create: XOR<DefensasCreateInput, DefensasUncheckedCreateInput>
    /**
     * In case the Defensas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefensasUpdateInput, DefensasUncheckedUpdateInput>
  }


  /**
   * Defensas delete
   */
  export type DefensasDeleteArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
    /**
     * Filter which Defensas to delete.
     */
    where: DefensasWhereUniqueInput
  }


  /**
   * Defensas deleteMany
   */
  export type DefensasDeleteManyArgs = {
    /**
     * Filter which Defensas to delete
     */
    where?: DefensasWhereInput
  }


  /**
   * Defensas.defensas_reinos
   */
  export type Defensas$defensas_reinosArgs = {
    /**
     * Select specific fields to fetch from the Defensas_reinos
     */
    select?: Defensas_reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Defensas_reinosInclude | null
    where?: Defensas_reinosWhereInput
    orderBy?: Enumerable<Defensas_reinosOrderByWithRelationInput>
    cursor?: Defensas_reinosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Defensas_reinosScalarFieldEnum>
  }


  /**
   * Defensas without action
   */
  export type DefensasArgs = {
    /**
     * Select specific fields to fetch from the Defensas
     */
    select?: DefensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DefensasInclude | null
  }



  /**
   * Model Diplomacias
   */


  export type AggregateDiplomacias = {
    _count: DiplomaciasCountAggregateOutputType | null
    _avg: DiplomaciasAvgAggregateOutputType | null
    _sum: DiplomaciasSumAggregateOutputType | null
    _min: DiplomaciasMinAggregateOutputType | null
    _max: DiplomaciasMaxAggregateOutputType | null
  }

  export type DiplomaciasAvgAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
  }

  export type DiplomaciasSumAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
  }

  export type DiplomaciasMinAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
    es_aliado: boolean | null
  }

  export type DiplomaciasMaxAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
    es_aliado: boolean | null
  }

  export type DiplomaciasCountAggregateOutputType = {
    id_reino_1: number
    id_reino_2: number
    es_aliado: number
    _all: number
  }


  export type DiplomaciasAvgAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
  }

  export type DiplomaciasSumAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
  }

  export type DiplomaciasMinAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
    es_aliado?: true
  }

  export type DiplomaciasMaxAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
    es_aliado?: true
  }

  export type DiplomaciasCountAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
    es_aliado?: true
    _all?: true
  }

  export type DiplomaciasAggregateArgs = {
    /**
     * Filter which Diplomacias to aggregate.
     */
    where?: DiplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomacias to fetch.
     */
    orderBy?: Enumerable<DiplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diplomacias
    **/
    _count?: true | DiplomaciasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiplomaciasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiplomaciasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiplomaciasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiplomaciasMaxAggregateInputType
  }

  export type GetDiplomaciasAggregateType<T extends DiplomaciasAggregateArgs> = {
        [P in keyof T & keyof AggregateDiplomacias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiplomacias[P]>
      : GetScalarType<T[P], AggregateDiplomacias[P]>
  }




  export type DiplomaciasGroupByArgs = {
    where?: DiplomaciasWhereInput
    orderBy?: Enumerable<DiplomaciasOrderByWithAggregationInput>
    by: DiplomaciasScalarFieldEnum[]
    having?: DiplomaciasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiplomaciasCountAggregateInputType | true
    _avg?: DiplomaciasAvgAggregateInputType
    _sum?: DiplomaciasSumAggregateInputType
    _min?: DiplomaciasMinAggregateInputType
    _max?: DiplomaciasMaxAggregateInputType
  }


  export type DiplomaciasGroupByOutputType = {
    id_reino_1: number
    id_reino_2: number
    es_aliado: boolean | null
    _count: DiplomaciasCountAggregateOutputType | null
    _avg: DiplomaciasAvgAggregateOutputType | null
    _sum: DiplomaciasSumAggregateOutputType | null
    _min: DiplomaciasMinAggregateOutputType | null
    _max: DiplomaciasMaxAggregateOutputType | null
  }

  type GetDiplomaciasGroupByPayload<T extends DiplomaciasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DiplomaciasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiplomaciasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiplomaciasGroupByOutputType[P]>
            : GetScalarType<T[P], DiplomaciasGroupByOutputType[P]>
        }
      >
    >


  export type DiplomaciasSelect = {
    id_reino_1?: boolean
    id_reino_2?: boolean
    es_aliado?: boolean
    reino1?: boolean | ReinosArgs
    reino2?: boolean | ReinosArgs
  }


  export type DiplomaciasInclude = {
    reino1?: boolean | ReinosArgs
    reino2?: boolean | ReinosArgs
  }

  export type DiplomaciasGetPayload<S extends boolean | null | undefined | DiplomaciasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Diplomacias :
    S extends undefined ? never :
    S extends { include: any } & (DiplomaciasArgs | DiplomaciasFindManyArgs)
    ? Diplomacias  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reino1' ? ReinosGetPayload<S['include'][P]> :
        P extends 'reino2' ? ReinosGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DiplomaciasArgs | DiplomaciasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reino1' ? ReinosGetPayload<S['select'][P]> :
        P extends 'reino2' ? ReinosGetPayload<S['select'][P]> :  P extends keyof Diplomacias ? Diplomacias[P] : never
  } 
      : Diplomacias


  type DiplomaciasCountArgs = 
    Omit<DiplomaciasFindManyArgs, 'select' | 'include'> & {
      select?: DiplomaciasCountAggregateInputType | true
    }

  export interface DiplomaciasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Diplomacias that matches the filter.
     * @param {DiplomaciasFindUniqueArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiplomaciasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiplomaciasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Diplomacias'> extends True ? Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>> : Prisma__DiplomaciasClient<DiplomaciasGetPayload<T> | null, null>

    /**
     * Find one Diplomacias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiplomaciasFindUniqueOrThrowArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiplomaciasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DiplomaciasFindUniqueOrThrowArgs>
    ): Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>>

    /**
     * Find the first Diplomacias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasFindFirstArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiplomaciasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiplomaciasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Diplomacias'> extends True ? Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>> : Prisma__DiplomaciasClient<DiplomaciasGetPayload<T> | null, null>

    /**
     * Find the first Diplomacias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasFindFirstOrThrowArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiplomaciasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DiplomaciasFindFirstOrThrowArgs>
    ): Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>>

    /**
     * Find zero or more Diplomacias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diplomacias
     * const diplomacias = await prisma.diplomacias.findMany()
     * 
     * // Get first 10 Diplomacias
     * const diplomacias = await prisma.diplomacias.findMany({ take: 10 })
     * 
     * // Only select the `id_reino_1`
     * const diplomaciasWithId_reino_1Only = await prisma.diplomacias.findMany({ select: { id_reino_1: true } })
     * 
    **/
    findMany<T extends DiplomaciasFindManyArgs>(
      args?: SelectSubset<T, DiplomaciasFindManyArgs>
    ): Prisma.PrismaPromise<Array<DiplomaciasGetPayload<T>>>

    /**
     * Create a Diplomacias.
     * @param {DiplomaciasCreateArgs} args - Arguments to create a Diplomacias.
     * @example
     * // Create one Diplomacias
     * const Diplomacias = await prisma.diplomacias.create({
     *   data: {
     *     // ... data to create a Diplomacias
     *   }
     * })
     * 
    **/
    create<T extends DiplomaciasCreateArgs>(
      args: SelectSubset<T, DiplomaciasCreateArgs>
    ): Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>>

    /**
     * Create many Diplomacias.
     *     @param {DiplomaciasCreateManyArgs} args - Arguments to create many Diplomacias.
     *     @example
     *     // Create many Diplomacias
     *     const diplomacias = await prisma.diplomacias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiplomaciasCreateManyArgs>(
      args?: SelectSubset<T, DiplomaciasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diplomacias.
     * @param {DiplomaciasDeleteArgs} args - Arguments to delete one Diplomacias.
     * @example
     * // Delete one Diplomacias
     * const Diplomacias = await prisma.diplomacias.delete({
     *   where: {
     *     // ... filter to delete one Diplomacias
     *   }
     * })
     * 
    **/
    delete<T extends DiplomaciasDeleteArgs>(
      args: SelectSubset<T, DiplomaciasDeleteArgs>
    ): Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>>

    /**
     * Update one Diplomacias.
     * @param {DiplomaciasUpdateArgs} args - Arguments to update one Diplomacias.
     * @example
     * // Update one Diplomacias
     * const diplomacias = await prisma.diplomacias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiplomaciasUpdateArgs>(
      args: SelectSubset<T, DiplomaciasUpdateArgs>
    ): Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>>

    /**
     * Delete zero or more Diplomacias.
     * @param {DiplomaciasDeleteManyArgs} args - Arguments to filter Diplomacias to delete.
     * @example
     * // Delete a few Diplomacias
     * const { count } = await prisma.diplomacias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiplomaciasDeleteManyArgs>(
      args?: SelectSubset<T, DiplomaciasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diplomacias
     * const diplomacias = await prisma.diplomacias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiplomaciasUpdateManyArgs>(
      args: SelectSubset<T, DiplomaciasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diplomacias.
     * @param {DiplomaciasUpsertArgs} args - Arguments to update or create a Diplomacias.
     * @example
     * // Update or create a Diplomacias
     * const diplomacias = await prisma.diplomacias.upsert({
     *   create: {
     *     // ... data to create a Diplomacias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diplomacias we want to update
     *   }
     * })
    **/
    upsert<T extends DiplomaciasUpsertArgs>(
      args: SelectSubset<T, DiplomaciasUpsertArgs>
    ): Prisma__DiplomaciasClient<DiplomaciasGetPayload<T>>

    /**
     * Count the number of Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasCountArgs} args - Arguments to filter Diplomacias to count.
     * @example
     * // Count the number of Diplomacias
     * const count = await prisma.diplomacias.count({
     *   where: {
     *     // ... the filter for the Diplomacias we want to count
     *   }
     * })
    **/
    count<T extends DiplomaciasCountArgs>(
      args?: Subset<T, DiplomaciasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiplomaciasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiplomaciasAggregateArgs>(args: Subset<T, DiplomaciasAggregateArgs>): Prisma.PrismaPromise<GetDiplomaciasAggregateType<T>>

    /**
     * Group by Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiplomaciasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiplomaciasGroupByArgs['orderBy'] }
        : { orderBy?: DiplomaciasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiplomaciasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiplomaciasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Diplomacias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiplomaciasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reino1<T extends ReinosArgs= {}>(args?: Subset<T, ReinosArgs>): Prisma__ReinosClient<ReinosGetPayload<T> | Null>;

    reino2<T extends ReinosArgs= {}>(args?: Subset<T, ReinosArgs>): Prisma__ReinosClient<ReinosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Diplomacias base type for findUnique actions
   */
  export type DiplomaciasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * Filter, which Diplomacias to fetch.
     */
    where: DiplomaciasWhereUniqueInput
  }

  /**
   * Diplomacias findUnique
   */
  export interface DiplomaciasFindUniqueArgs extends DiplomaciasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Diplomacias findUniqueOrThrow
   */
  export type DiplomaciasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * Filter, which Diplomacias to fetch.
     */
    where: DiplomaciasWhereUniqueInput
  }


  /**
   * Diplomacias base type for findFirst actions
   */
  export type DiplomaciasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * Filter, which Diplomacias to fetch.
     */
    where?: DiplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomacias to fetch.
     */
    orderBy?: Enumerable<DiplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diplomacias.
     */
    cursor?: DiplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diplomacias.
     */
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }

  /**
   * Diplomacias findFirst
   */
  export interface DiplomaciasFindFirstArgs extends DiplomaciasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Diplomacias findFirstOrThrow
   */
  export type DiplomaciasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * Filter, which Diplomacias to fetch.
     */
    where?: DiplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomacias to fetch.
     */
    orderBy?: Enumerable<DiplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diplomacias.
     */
    cursor?: DiplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diplomacias.
     */
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * Diplomacias findMany
   */
  export type DiplomaciasFindManyArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * Filter, which Diplomacias to fetch.
     */
    where?: DiplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomacias to fetch.
     */
    orderBy?: Enumerable<DiplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diplomacias.
     */
    cursor?: DiplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomacias.
     */
    skip?: number
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * Diplomacias create
   */
  export type DiplomaciasCreateArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * The data needed to create a Diplomacias.
     */
    data: XOR<DiplomaciasCreateInput, DiplomaciasUncheckedCreateInput>
  }


  /**
   * Diplomacias createMany
   */
  export type DiplomaciasCreateManyArgs = {
    /**
     * The data used to create many Diplomacias.
     */
    data: Enumerable<DiplomaciasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Diplomacias update
   */
  export type DiplomaciasUpdateArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * The data needed to update a Diplomacias.
     */
    data: XOR<DiplomaciasUpdateInput, DiplomaciasUncheckedUpdateInput>
    /**
     * Choose, which Diplomacias to update.
     */
    where: DiplomaciasWhereUniqueInput
  }


  /**
   * Diplomacias updateMany
   */
  export type DiplomaciasUpdateManyArgs = {
    /**
     * The data used to update Diplomacias.
     */
    data: XOR<DiplomaciasUpdateManyMutationInput, DiplomaciasUncheckedUpdateManyInput>
    /**
     * Filter which Diplomacias to update
     */
    where?: DiplomaciasWhereInput
  }


  /**
   * Diplomacias upsert
   */
  export type DiplomaciasUpsertArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * The filter to search for the Diplomacias to update in case it exists.
     */
    where: DiplomaciasWhereUniqueInput
    /**
     * In case the Diplomacias found by the `where` argument doesn't exist, create a new Diplomacias with this data.
     */
    create: XOR<DiplomaciasCreateInput, DiplomaciasUncheckedCreateInput>
    /**
     * In case the Diplomacias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiplomaciasUpdateInput, DiplomaciasUncheckedUpdateInput>
  }


  /**
   * Diplomacias delete
   */
  export type DiplomaciasDeleteArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
    /**
     * Filter which Diplomacias to delete.
     */
    where: DiplomaciasWhereUniqueInput
  }


  /**
   * Diplomacias deleteMany
   */
  export type DiplomaciasDeleteManyArgs = {
    /**
     * Filter which Diplomacias to delete
     */
    where?: DiplomaciasWhereInput
  }


  /**
   * Diplomacias without action
   */
  export type DiplomaciasArgs = {
    /**
     * Select specific fields to fetch from the Diplomacias
     */
    select?: DiplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiplomaciasInclude | null
  }



  /**
   * Enums
   */

  export const DefensasScalarFieldEnum: {
    id: 'id',
    defensa: 'defensa'
  };

  export type DefensasScalarFieldEnum = (typeof DefensasScalarFieldEnum)[keyof typeof DefensasScalarFieldEnum]


  export const Defensas_reinosScalarFieldEnum: {
    id_reinos: 'id_reinos',
    id_defensas: 'id_defensas'
  };

  export type Defensas_reinosScalarFieldEnum = (typeof Defensas_reinosScalarFieldEnum)[keyof typeof Defensas_reinosScalarFieldEnum]


  export const DiplomaciasScalarFieldEnum: {
    id_reino_1: 'id_reino_1',
    id_reino_2: 'id_reino_2',
    es_aliado: 'es_aliado'
  };

  export type DiplomaciasScalarFieldEnum = (typeof DiplomaciasScalarFieldEnum)[keyof typeof DiplomaciasScalarFieldEnum]


  export const KartsScalarFieldEnum: {
    id: 'id',
    modelo: 'modelo',
    color: 'color',
    velocidad_maxima: 'velocidad_maxima',
    id_personaje: 'id_personaje'
  };

  export type KartsScalarFieldEnum = (typeof KartsScalarFieldEnum)[keyof typeof KartsScalarFieldEnum]


  export const Personaje_habita_reinoScalarFieldEnum: {
    id_personaje: 'id_personaje',
    id_reino: 'id_reino',
    fecha_registro: 'fecha_registro',
    es_gobernante: 'es_gobernante'
  };

  export type Personaje_habita_reinoScalarFieldEnum = (typeof Personaje_habita_reinoScalarFieldEnum)[keyof typeof Personaje_habita_reinoScalarFieldEnum]


  export const Personaje_tiene_trabajoScalarFieldEnum: {
    id_trabajo: 'id_trabajo',
    id_personaje: 'id_personaje',
    fecha_inicio: 'fecha_inicio',
    fecha_termino: 'fecha_termino'
  };

  export type Personaje_tiene_trabajoScalarFieldEnum = (typeof Personaje_tiene_trabajoScalarFieldEnum)[keyof typeof Personaje_tiene_trabajoScalarFieldEnum]


  export const PersonajesScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    fuerza: 'fuerza',
    fecha_nacimiento: 'fecha_nacimiento',
    objeto: 'objeto'
  };

  export type PersonajesScalarFieldEnum = (typeof PersonajesScalarFieldEnum)[keyof typeof PersonajesScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ReinosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    ubicacion: 'ubicacion',
    superficie: 'superficie'
  };

  export type ReinosScalarFieldEnum = (typeof ReinosScalarFieldEnum)[keyof typeof ReinosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TrabajosScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    sueldo: 'sueldo'
  };

  export type TrabajosScalarFieldEnum = (typeof TrabajosScalarFieldEnum)[keyof typeof TrabajosScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type PersonajesWhereInput = {
    AND?: Enumerable<PersonajesWhereInput>
    OR?: Enumerable<PersonajesWhereInput>
    NOT?: Enumerable<PersonajesWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    fuerza?: IntFilter | number
    fecha_nacimiento?: DateTimeFilter | Date | string
    objeto?: StringNullableFilter | string | null
    kart?: KartsListRelationFilter
    personaje_tiene_trabajo?: Personaje_tiene_trabajoListRelationFilter
    personaje_habita_reino?: Personaje_habita_reinoListRelationFilter
  }

  export type PersonajesOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
    kart?: KartsOrderByRelationAggregateInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoOrderByRelationAggregateInput
    personaje_habita_reino?: Personaje_habita_reinoOrderByRelationAggregateInput
  }

  export type PersonajesWhereUniqueInput = {
    id?: number
  }

  export type PersonajesOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
    _count?: PersonajesCountOrderByAggregateInput
    _avg?: PersonajesAvgOrderByAggregateInput
    _max?: PersonajesMaxOrderByAggregateInput
    _min?: PersonajesMinOrderByAggregateInput
    _sum?: PersonajesSumOrderByAggregateInput
  }

  export type PersonajesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonajesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonajesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonajesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    fuerza?: IntWithAggregatesFilter | number
    fecha_nacimiento?: DateTimeWithAggregatesFilter | Date | string
    objeto?: StringNullableWithAggregatesFilter | string | null
  }

  export type KartsWhereInput = {
    AND?: Enumerable<KartsWhereInput>
    OR?: Enumerable<KartsWhereInput>
    NOT?: Enumerable<KartsWhereInput>
    id?: IntFilter | number
    modelo?: StringFilter | string
    color?: StringFilter | string
    velocidad_maxima?: IntNullableFilter | number | null
    id_personaje?: IntFilter | number
    personaje?: XOR<PersonajesRelationFilter, PersonajesWhereInput> | null
  }

  export type KartsOrderByWithRelationInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
    personaje?: PersonajesOrderByWithRelationInput
  }

  export type KartsWhereUniqueInput = {
    id?: number
  }

  export type KartsOrderByWithAggregationInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
    _count?: KartsCountOrderByAggregateInput
    _avg?: KartsAvgOrderByAggregateInput
    _max?: KartsMaxOrderByAggregateInput
    _min?: KartsMinOrderByAggregateInput
    _sum?: KartsSumOrderByAggregateInput
  }

  export type KartsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KartsScalarWhereWithAggregatesInput>
    OR?: Enumerable<KartsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KartsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    modelo?: StringWithAggregatesFilter | string
    color?: StringWithAggregatesFilter | string
    velocidad_maxima?: IntNullableWithAggregatesFilter | number | null
    id_personaje?: IntWithAggregatesFilter | number
  }

  export type Personaje_tiene_trabajoWhereInput = {
    AND?: Enumerable<Personaje_tiene_trabajoWhereInput>
    OR?: Enumerable<Personaje_tiene_trabajoWhereInput>
    NOT?: Enumerable<Personaje_tiene_trabajoWhereInput>
    id_trabajo?: IntFilter | number
    id_personaje?: IntFilter | number
    fecha_inicio?: DateTimeFilter | Date | string
    fecha_termino?: DateTimeNullableFilter | Date | string | null
    trabajo?: XOR<TrabajosRelationFilter, TrabajosWhereInput>
    personaje?: XOR<PersonajesRelationFilter, PersonajesWhereInput>
  }

  export type Personaje_tiene_trabajoOrderByWithRelationInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    trabajo?: TrabajosOrderByWithRelationInput
    personaje?: PersonajesOrderByWithRelationInput
  }

  export type Personaje_tiene_trabajoWhereUniqueInput = {
    id_trabajo?: number
    id_personaje?: number
  }

  export type Personaje_tiene_trabajoOrderByWithAggregationInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    _count?: Personaje_tiene_trabajoCountOrderByAggregateInput
    _avg?: Personaje_tiene_trabajoAvgOrderByAggregateInput
    _max?: Personaje_tiene_trabajoMaxOrderByAggregateInput
    _min?: Personaje_tiene_trabajoMinOrderByAggregateInput
    _sum?: Personaje_tiene_trabajoSumOrderByAggregateInput
  }

  export type Personaje_tiene_trabajoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Personaje_tiene_trabajoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Personaje_tiene_trabajoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Personaje_tiene_trabajoScalarWhereWithAggregatesInput>
    id_trabajo?: IntWithAggregatesFilter | number
    id_personaje?: IntWithAggregatesFilter | number
    fecha_inicio?: DateTimeWithAggregatesFilter | Date | string
    fecha_termino?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TrabajosWhereInput = {
    AND?: Enumerable<TrabajosWhereInput>
    OR?: Enumerable<TrabajosWhereInput>
    NOT?: Enumerable<TrabajosWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    sueldo?: IntFilter | number
    personaje_tiene_trabajo?: Personaje_tiene_trabajoListRelationFilter
  }

  export type TrabajosOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
    personaje_tiene_trabajo?: Personaje_tiene_trabajoOrderByRelationAggregateInput
  }

  export type TrabajosWhereUniqueInput = {
    id?: number
  }

  export type TrabajosOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
    _count?: TrabajosCountOrderByAggregateInput
    _avg?: TrabajosAvgOrderByAggregateInput
    _max?: TrabajosMaxOrderByAggregateInput
    _min?: TrabajosMinOrderByAggregateInput
    _sum?: TrabajosSumOrderByAggregateInput
  }

  export type TrabajosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrabajosScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrabajosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrabajosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    sueldo?: IntWithAggregatesFilter | number
  }

  export type Personaje_habita_reinoWhereInput = {
    AND?: Enumerable<Personaje_habita_reinoWhereInput>
    OR?: Enumerable<Personaje_habita_reinoWhereInput>
    NOT?: Enumerable<Personaje_habita_reinoWhereInput>
    id_personaje?: IntFilter | number
    id_reino?: IntFilter | number
    fecha_registro?: DateTimeFilter | Date | string
    es_gobernante?: BoolFilter | boolean
    personaje?: XOR<PersonajesRelationFilter, PersonajesWhereInput>
    reino?: XOR<ReinosRelationFilter, ReinosWhereInput>
  }

  export type Personaje_habita_reinoOrderByWithRelationInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
    personaje?: PersonajesOrderByWithRelationInput
    reino?: ReinosOrderByWithRelationInput
  }

  export type Personaje_habita_reinoWhereUniqueInput = {
    id_personaje?: number
    id_reino?: number
  }

  export type Personaje_habita_reinoOrderByWithAggregationInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
    _count?: Personaje_habita_reinoCountOrderByAggregateInput
    _avg?: Personaje_habita_reinoAvgOrderByAggregateInput
    _max?: Personaje_habita_reinoMaxOrderByAggregateInput
    _min?: Personaje_habita_reinoMinOrderByAggregateInput
    _sum?: Personaje_habita_reinoSumOrderByAggregateInput
  }

  export type Personaje_habita_reinoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Personaje_habita_reinoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Personaje_habita_reinoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Personaje_habita_reinoScalarWhereWithAggregatesInput>
    id_personaje?: IntWithAggregatesFilter | number
    id_reino?: IntWithAggregatesFilter | number
    fecha_registro?: DateTimeWithAggregatesFilter | Date | string
    es_gobernante?: BoolWithAggregatesFilter | boolean
  }

  export type ReinosWhereInput = {
    AND?: Enumerable<ReinosWhereInput>
    OR?: Enumerable<ReinosWhereInput>
    NOT?: Enumerable<ReinosWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    ubicacion?: StringFilter | string
    superficie?: IntFilter | number
    personaje_habita_reino?: Personaje_habita_reinoListRelationFilter
    defensas_reinos?: Defensas_reinosListRelationFilter
    diplomacia1?: DiplomaciasListRelationFilter
    diplomacia2?: DiplomaciasListRelationFilter
  }

  export type ReinosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
    personaje_habita_reino?: Personaje_habita_reinoOrderByRelationAggregateInput
    defensas_reinos?: Defensas_reinosOrderByRelationAggregateInput
    diplomacia1?: DiplomaciasOrderByRelationAggregateInput
    diplomacia2?: DiplomaciasOrderByRelationAggregateInput
  }

  export type ReinosWhereUniqueInput = {
    id?: number
  }

  export type ReinosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
    _count?: ReinosCountOrderByAggregateInput
    _avg?: ReinosAvgOrderByAggregateInput
    _max?: ReinosMaxOrderByAggregateInput
    _min?: ReinosMinOrderByAggregateInput
    _sum?: ReinosSumOrderByAggregateInput
  }

  export type ReinosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReinosScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReinosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReinosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    ubicacion?: StringWithAggregatesFilter | string
    superficie?: IntWithAggregatesFilter | number
  }

  export type Defensas_reinosWhereInput = {
    AND?: Enumerable<Defensas_reinosWhereInput>
    OR?: Enumerable<Defensas_reinosWhereInput>
    NOT?: Enumerable<Defensas_reinosWhereInput>
    id_reinos?: IntFilter | number
    id_defensas?: IntFilter | number
    reino?: XOR<ReinosRelationFilter, ReinosWhereInput>
    defensa?: XOR<DefensasRelationFilter, DefensasWhereInput>
  }

  export type Defensas_reinosOrderByWithRelationInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
    reino?: ReinosOrderByWithRelationInput
    defensa?: DefensasOrderByWithRelationInput
  }

  export type Defensas_reinosWhereUniqueInput = {
    id_reinos?: number
    id_defensas?: number
  }

  export type Defensas_reinosOrderByWithAggregationInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
    _count?: Defensas_reinosCountOrderByAggregateInput
    _avg?: Defensas_reinosAvgOrderByAggregateInput
    _max?: Defensas_reinosMaxOrderByAggregateInput
    _min?: Defensas_reinosMinOrderByAggregateInput
    _sum?: Defensas_reinosSumOrderByAggregateInput
  }

  export type Defensas_reinosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Defensas_reinosScalarWhereWithAggregatesInput>
    OR?: Enumerable<Defensas_reinosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Defensas_reinosScalarWhereWithAggregatesInput>
    id_reinos?: IntWithAggregatesFilter | number
    id_defensas?: IntWithAggregatesFilter | number
  }

  export type DefensasWhereInput = {
    AND?: Enumerable<DefensasWhereInput>
    OR?: Enumerable<DefensasWhereInput>
    NOT?: Enumerable<DefensasWhereInput>
    id?: IntFilter | number
    defensa?: StringFilter | string
    defensas_reinos?: Defensas_reinosListRelationFilter
  }

  export type DefensasOrderByWithRelationInput = {
    id?: SortOrder
    defensa?: SortOrder
    defensas_reinos?: Defensas_reinosOrderByRelationAggregateInput
  }

  export type DefensasWhereUniqueInput = {
    id?: number
  }

  export type DefensasOrderByWithAggregationInput = {
    id?: SortOrder
    defensa?: SortOrder
    _count?: DefensasCountOrderByAggregateInput
    _avg?: DefensasAvgOrderByAggregateInput
    _max?: DefensasMaxOrderByAggregateInput
    _min?: DefensasMinOrderByAggregateInput
    _sum?: DefensasSumOrderByAggregateInput
  }

  export type DefensasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DefensasScalarWhereWithAggregatesInput>
    OR?: Enumerable<DefensasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DefensasScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    defensa?: StringWithAggregatesFilter | string
  }

  export type DiplomaciasWhereInput = {
    AND?: Enumerable<DiplomaciasWhereInput>
    OR?: Enumerable<DiplomaciasWhereInput>
    NOT?: Enumerable<DiplomaciasWhereInput>
    id_reino_1?: IntFilter | number
    id_reino_2?: IntFilter | number
    es_aliado?: BoolNullableFilter | boolean | null
    reino1?: XOR<ReinosRelationFilter, ReinosWhereInput>
    reino2?: XOR<ReinosRelationFilter, ReinosWhereInput>
  }

  export type DiplomaciasOrderByWithRelationInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
    reino1?: ReinosOrderByWithRelationInput
    reino2?: ReinosOrderByWithRelationInput
  }

  export type DiplomaciasWhereUniqueInput = {
    id_reino_1?: number
    id_reino_2?: number
  }

  export type DiplomaciasOrderByWithAggregationInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
    _count?: DiplomaciasCountOrderByAggregateInput
    _avg?: DiplomaciasAvgOrderByAggregateInput
    _max?: DiplomaciasMaxOrderByAggregateInput
    _min?: DiplomaciasMinOrderByAggregateInput
    _sum?: DiplomaciasSumOrderByAggregateInput
  }

  export type DiplomaciasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiplomaciasScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiplomaciasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiplomaciasScalarWhereWithAggregatesInput>
    id_reino_1?: IntWithAggregatesFilter | number
    id_reino_2?: IntWithAggregatesFilter | number
    es_aliado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type PersonajesCreateInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    kart?: KartsCreateNestedManyWithoutPersonajeInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesUncheckedCreateInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    kart?: KartsUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    kart?: KartsUpdateManyWithoutPersonajeNestedInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput
  }

  export type PersonajesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    kart?: KartsUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type PersonajesCreateManyInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
  }

  export type PersonajesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonajesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KartsCreateInput = {
    id: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
    personaje?: PersonajesCreateNestedOneWithoutKartInput
  }

  export type KartsUncheckedCreateInput = {
    id: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
    id_personaje: number
  }

  export type KartsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
    personaje?: PersonajesUpdateOneWithoutKartNestedInput
  }

  export type KartsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
    id_personaje?: IntFieldUpdateOperationsInput | number
  }

  export type KartsCreateManyInput = {
    id: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
    id_personaje: number
  }

  export type KartsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KartsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
    id_personaje?: IntFieldUpdateOperationsInput | number
  }

  export type Personaje_tiene_trabajoCreateInput = {
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
    trabajo: TrabajosCreateNestedOneWithoutPersonaje_tiene_trabajoInput
    personaje: PersonajesCreateNestedOneWithoutPersonaje_tiene_trabajoInput
  }

  export type Personaje_tiene_trabajoUncheckedCreateInput = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type Personaje_tiene_trabajoUpdateInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trabajo?: TrabajosUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
    personaje?: PersonajesUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
  }

  export type Personaje_tiene_trabajoUncheckedUpdateInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Personaje_tiene_trabajoCreateManyInput = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type Personaje_tiene_trabajoUpdateManyMutationInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Personaje_tiene_trabajoUncheckedUpdateManyInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrabajosCreateInput = {
    id: number
    descripcion: string
    sueldo: number
    personaje_tiene_trabajo?: Personaje_tiene_trabajoCreateNestedManyWithoutTrabajoInput
  }

  export type TrabajosUncheckedCreateInput = {
    id: number
    descripcion: string
    sueldo: number
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedCreateNestedManyWithoutTrabajoInput
  }

  export type TrabajosUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUpdateManyWithoutTrabajoNestedInput
  }

  export type TrabajosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedUpdateManyWithoutTrabajoNestedInput
  }

  export type TrabajosCreateManyInput = {
    id: number
    descripcion: string
    sueldo: number
  }

  export type TrabajosUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type TrabajosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type Personaje_habita_reinoCreateInput = {
    fecha_registro: Date | string
    es_gobernante: boolean
    personaje: PersonajesCreateNestedOneWithoutPersonaje_habita_reinoInput
    reino: ReinosCreateNestedOneWithoutPersonaje_habita_reinoInput
  }

  export type Personaje_habita_reinoUncheckedCreateInput = {
    id_personaje: number
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type Personaje_habita_reinoUpdateInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
    personaje?: PersonajesUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
    reino?: ReinosUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
  }

  export type Personaje_habita_reinoUncheckedUpdateInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Personaje_habita_reinoCreateManyInput = {
    id_personaje: number
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type Personaje_habita_reinoUpdateManyMutationInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Personaje_habita_reinoUncheckedUpdateManyInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReinosCreateInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutReinoInput
    defensas_reinos?: Defensas_reinosCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasCreateNestedManyWithoutReino1Input
    diplomacia2?: DiplomaciasCreateNestedManyWithoutReino2Input
  }

  export type ReinosUncheckedCreateInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    defensas_reinos?: Defensas_reinosUncheckedCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasUncheckedCreateNestedManyWithoutReino1Input
    diplomacia2?: DiplomaciasUncheckedCreateNestedManyWithoutReino2Input
  }

  export type ReinosUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    defensas_reinos?: Defensas_reinosUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUpdateManyWithoutReino1NestedInput
    diplomacia2?: DiplomaciasUpdateManyWithoutReino2NestedInput
  }

  export type ReinosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    defensas_reinos?: Defensas_reinosUncheckedUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    diplomacia2?: DiplomaciasUncheckedUpdateManyWithoutReino2NestedInput
  }

  export type ReinosCreateManyInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
  }

  export type ReinosUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
  }

  export type ReinosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
  }

  export type Defensas_reinosCreateInput = {
    reino: ReinosCreateNestedOneWithoutDefensas_reinosInput
    defensa: DefensasCreateNestedOneWithoutDefensas_reinosInput
  }

  export type Defensas_reinosUncheckedCreateInput = {
    id_reinos: number
    id_defensas: number
  }

  export type Defensas_reinosUpdateInput = {
    reino?: ReinosUpdateOneRequiredWithoutDefensas_reinosNestedInput
    defensa?: DefensasUpdateOneRequiredWithoutDefensas_reinosNestedInput
  }

  export type Defensas_reinosUncheckedUpdateInput = {
    id_reinos?: IntFieldUpdateOperationsInput | number
    id_defensas?: IntFieldUpdateOperationsInput | number
  }

  export type Defensas_reinosCreateManyInput = {
    id_reinos: number
    id_defensas: number
  }

  export type Defensas_reinosUpdateManyMutationInput = {

  }

  export type Defensas_reinosUncheckedUpdateManyInput = {
    id_reinos?: IntFieldUpdateOperationsInput | number
    id_defensas?: IntFieldUpdateOperationsInput | number
  }

  export type DefensasCreateInput = {
    id: number
    defensa: string
    defensas_reinos?: Defensas_reinosCreateNestedManyWithoutDefensaInput
  }

  export type DefensasUncheckedCreateInput = {
    id: number
    defensa: string
    defensas_reinos?: Defensas_reinosUncheckedCreateNestedManyWithoutDefensaInput
  }

  export type DefensasUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
    defensas_reinos?: Defensas_reinosUpdateManyWithoutDefensaNestedInput
  }

  export type DefensasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
    defensas_reinos?: Defensas_reinosUncheckedUpdateManyWithoutDefensaNestedInput
  }

  export type DefensasCreateManyInput = {
    id: number
    defensa: string
  }

  export type DefensasUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type DefensasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomaciasCreateInput = {
    es_aliado?: boolean | null
    reino1: ReinosCreateNestedOneWithoutDiplomacia1Input
    reino2: ReinosCreateNestedOneWithoutDiplomacia2Input
  }

  export type DiplomaciasUncheckedCreateInput = {
    id_reino_1: number
    id_reino_2: number
    es_aliado?: boolean | null
  }

  export type DiplomaciasUpdateInput = {
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reino1?: ReinosUpdateOneRequiredWithoutDiplomacia1NestedInput
    reino2?: ReinosUpdateOneRequiredWithoutDiplomacia2NestedInput
  }

  export type DiplomaciasUncheckedUpdateInput = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DiplomaciasCreateManyInput = {
    id_reino_1: number
    id_reino_2: number
    es_aliado?: boolean | null
  }

  export type DiplomaciasUpdateManyMutationInput = {
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DiplomaciasUncheckedUpdateManyInput = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type KartsListRelationFilter = {
    every?: KartsWhereInput
    some?: KartsWhereInput
    none?: KartsWhereInput
  }

  export type Personaje_tiene_trabajoListRelationFilter = {
    every?: Personaje_tiene_trabajoWhereInput
    some?: Personaje_tiene_trabajoWhereInput
    none?: Personaje_tiene_trabajoWhereInput
  }

  export type Personaje_habita_reinoListRelationFilter = {
    every?: Personaje_habita_reinoWhereInput
    some?: Personaje_habita_reinoWhereInput
    none?: Personaje_habita_reinoWhereInput
  }

  export type KartsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Personaje_tiene_trabajoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Personaje_habita_reinoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonajesCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
  }

  export type PersonajesAvgOrderByAggregateInput = {
    id?: SortOrder
    fuerza?: SortOrder
  }

  export type PersonajesMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
  }

  export type PersonajesMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
  }

  export type PersonajesSumOrderByAggregateInput = {
    id?: SortOrder
    fuerza?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PersonajesRelationFilter = {
    is?: PersonajesWhereInput
    isNot?: PersonajesWhereInput
  }

  export type KartsCountOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type KartsAvgOrderByAggregateInput = {
    id?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type KartsMaxOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type KartsMinOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type KartsSumOrderByAggregateInput = {
    id?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type TrabajosRelationFilter = {
    is?: TrabajosWhereInput
    isNot?: TrabajosWhereInput
  }

  export type Personaje_tiene_trabajoCountOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
  }

  export type Personaje_tiene_trabajoAvgOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
  }

  export type Personaje_tiene_trabajoMaxOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
  }

  export type Personaje_tiene_trabajoMinOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
  }

  export type Personaje_tiene_trabajoSumOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type TrabajosCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
  }

  export type TrabajosAvgOrderByAggregateInput = {
    id?: SortOrder
    sueldo?: SortOrder
  }

  export type TrabajosMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
  }

  export type TrabajosMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
  }

  export type TrabajosSumOrderByAggregateInput = {
    id?: SortOrder
    sueldo?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ReinosRelationFilter = {
    is?: ReinosWhereInput
    isNot?: ReinosWhereInput
  }

  export type Personaje_habita_reinoCountOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
  }

  export type Personaje_habita_reinoAvgOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
  }

  export type Personaje_habita_reinoMaxOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
  }

  export type Personaje_habita_reinoMinOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
  }

  export type Personaje_habita_reinoSumOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type Defensas_reinosListRelationFilter = {
    every?: Defensas_reinosWhereInput
    some?: Defensas_reinosWhereInput
    none?: Defensas_reinosWhereInput
  }

  export type DiplomaciasListRelationFilter = {
    every?: DiplomaciasWhereInput
    some?: DiplomaciasWhereInput
    none?: DiplomaciasWhereInput
  }

  export type Defensas_reinosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiplomaciasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReinosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
  }

  export type ReinosAvgOrderByAggregateInput = {
    id?: SortOrder
    superficie?: SortOrder
  }

  export type ReinosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
  }

  export type ReinosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
  }

  export type ReinosSumOrderByAggregateInput = {
    id?: SortOrder
    superficie?: SortOrder
  }

  export type DefensasRelationFilter = {
    is?: DefensasWhereInput
    isNot?: DefensasWhereInput
  }

  export type Defensas_reinosCountOrderByAggregateInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
  }

  export type Defensas_reinosAvgOrderByAggregateInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
  }

  export type Defensas_reinosMaxOrderByAggregateInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
  }

  export type Defensas_reinosMinOrderByAggregateInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
  }

  export type Defensas_reinosSumOrderByAggregateInput = {
    id_reinos?: SortOrder
    id_defensas?: SortOrder
  }

  export type DefensasCountOrderByAggregateInput = {
    id?: SortOrder
    defensa?: SortOrder
  }

  export type DefensasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DefensasMaxOrderByAggregateInput = {
    id?: SortOrder
    defensa?: SortOrder
  }

  export type DefensasMinOrderByAggregateInput = {
    id?: SortOrder
    defensa?: SortOrder
  }

  export type DefensasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type DiplomaciasCountOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
  }

  export type DiplomaciasAvgOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
  }

  export type DiplomaciasMaxOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
  }

  export type DiplomaciasMinOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
  }

  export type DiplomaciasSumOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type KartsCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<KartsCreateWithoutPersonajeInput>, Enumerable<KartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<KartsCreateOrConnectWithoutPersonajeInput>
    createMany?: KartsCreateManyPersonajeInputEnvelope
    connect?: Enumerable<KartsWhereUniqueInput>
  }

  export type Personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    createMany?: Personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
  }

  export type Personaje_habita_reinoCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    createMany?: Personaje_habita_reinoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
  }

  export type KartsUncheckedCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<KartsCreateWithoutPersonajeInput>, Enumerable<KartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<KartsCreateOrConnectWithoutPersonajeInput>
    createMany?: KartsCreateManyPersonajeInputEnvelope
    connect?: Enumerable<KartsWhereUniqueInput>
  }

  export type Personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    createMany?: Personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
  }

  export type Personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    createMany?: Personaje_habita_reinoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type KartsUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<KartsCreateWithoutPersonajeInput>, Enumerable<KartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<KartsCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<KartsUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: KartsCreateManyPersonajeInputEnvelope
    set?: Enumerable<KartsWhereUniqueInput>
    disconnect?: Enumerable<KartsWhereUniqueInput>
    delete?: Enumerable<KartsWhereUniqueInput>
    connect?: Enumerable<KartsWhereUniqueInput>
    update?: Enumerable<KartsUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<KartsUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<KartsScalarWhereInput>
  }

  export type Personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<Personaje_tiene_trabajoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: Personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    set?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<Personaje_tiene_trabajoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<Personaje_tiene_trabajoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
  }

  export type Personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<Personaje_habita_reinoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: Personaje_habita_reinoCreateManyPersonajeInputEnvelope
    set?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<Personaje_habita_reinoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<Personaje_habita_reinoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<Personaje_habita_reinoScalarWhereInput>
  }

  export type KartsUncheckedUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<KartsCreateWithoutPersonajeInput>, Enumerable<KartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<KartsCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<KartsUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: KartsCreateManyPersonajeInputEnvelope
    set?: Enumerable<KartsWhereUniqueInput>
    disconnect?: Enumerable<KartsWhereUniqueInput>
    delete?: Enumerable<KartsWhereUniqueInput>
    connect?: Enumerable<KartsWhereUniqueInput>
    update?: Enumerable<KartsUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<KartsUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<KartsScalarWhereInput>
  }

  export type Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<Personaje_tiene_trabajoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: Personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    set?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<Personaje_tiene_trabajoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<Personaje_tiene_trabajoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
  }

  export type Personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<Personaje_habita_reinoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: Personaje_habita_reinoCreateManyPersonajeInputEnvelope
    set?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<Personaje_habita_reinoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<Personaje_habita_reinoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<Personaje_habita_reinoScalarWhereInput>
  }

  export type PersonajesCreateNestedOneWithoutKartInput = {
    create?: XOR<PersonajesCreateWithoutKartInput, PersonajesUncheckedCreateWithoutKartInput>
    connectOrCreate?: PersonajesCreateOrConnectWithoutKartInput
    connect?: PersonajesWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonajesUpdateOneWithoutKartNestedInput = {
    create?: XOR<PersonajesCreateWithoutKartInput, PersonajesUncheckedCreateWithoutKartInput>
    connectOrCreate?: PersonajesCreateOrConnectWithoutKartInput
    upsert?: PersonajesUpsertWithoutKartInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonajesWhereUniqueInput
    update?: XOR<PersonajesUpdateWithoutKartInput, PersonajesUncheckedUpdateWithoutKartInput>
  }

  export type TrabajosCreateNestedOneWithoutPersonaje_tiene_trabajoInput = {
    create?: XOR<TrabajosCreateWithoutPersonaje_tiene_trabajoInput, TrabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: TrabajosCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    connect?: TrabajosWhereUniqueInput
  }

  export type PersonajesCreateNestedOneWithoutPersonaje_tiene_trabajoInput = {
    create?: XOR<PersonajesCreateWithoutPersonaje_tiene_trabajoInput, PersonajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: PersonajesCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    connect?: PersonajesWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TrabajosUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput = {
    create?: XOR<TrabajosCreateWithoutPersonaje_tiene_trabajoInput, TrabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: TrabajosCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    upsert?: TrabajosUpsertWithoutPersonaje_tiene_trabajoInput
    connect?: TrabajosWhereUniqueInput
    update?: XOR<TrabajosUpdateWithoutPersonaje_tiene_trabajoInput, TrabajosUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
  }

  export type PersonajesUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput = {
    create?: XOR<PersonajesCreateWithoutPersonaje_tiene_trabajoInput, PersonajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: PersonajesCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    upsert?: PersonajesUpsertWithoutPersonaje_tiene_trabajoInput
    connect?: PersonajesWhereUniqueInput
    update?: XOR<PersonajesUpdateWithoutPersonaje_tiene_trabajoInput, PersonajesUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
  }

  export type Personaje_tiene_trabajoCreateNestedManyWithoutTrabajoInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    createMany?: Personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
  }

  export type Personaje_tiene_trabajoUncheckedCreateNestedManyWithoutTrabajoInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    createMany?: Personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
  }

  export type Personaje_tiene_trabajoUpdateManyWithoutTrabajoNestedInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    upsert?: Enumerable<Personaje_tiene_trabajoUpsertWithWhereUniqueWithoutTrabajoInput>
    createMany?: Personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    set?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<Personaje_tiene_trabajoUpdateWithWhereUniqueWithoutTrabajoInput>
    updateMany?: Enumerable<Personaje_tiene_trabajoUpdateManyWithWhereWithoutTrabajoInput>
    deleteMany?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
  }

  export type Personaje_tiene_trabajoUncheckedUpdateManyWithoutTrabajoNestedInput = {
    create?: XOR<Enumerable<Personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<Personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    upsert?: Enumerable<Personaje_tiene_trabajoUpsertWithWhereUniqueWithoutTrabajoInput>
    createMany?: Personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    set?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<Personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<Personaje_tiene_trabajoUpdateWithWhereUniqueWithoutTrabajoInput>
    updateMany?: Enumerable<Personaje_tiene_trabajoUpdateManyWithWhereWithoutTrabajoInput>
    deleteMany?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
  }

  export type PersonajesCreateNestedOneWithoutPersonaje_habita_reinoInput = {
    create?: XOR<PersonajesCreateWithoutPersonaje_habita_reinoInput, PersonajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: PersonajesCreateOrConnectWithoutPersonaje_habita_reinoInput
    connect?: PersonajesWhereUniqueInput
  }

  export type ReinosCreateNestedOneWithoutPersonaje_habita_reinoInput = {
    create?: XOR<ReinosCreateWithoutPersonaje_habita_reinoInput, ReinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: ReinosCreateOrConnectWithoutPersonaje_habita_reinoInput
    connect?: ReinosWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonajesUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput = {
    create?: XOR<PersonajesCreateWithoutPersonaje_habita_reinoInput, PersonajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: PersonajesCreateOrConnectWithoutPersonaje_habita_reinoInput
    upsert?: PersonajesUpsertWithoutPersonaje_habita_reinoInput
    connect?: PersonajesWhereUniqueInput
    update?: XOR<PersonajesUpdateWithoutPersonaje_habita_reinoInput, PersonajesUncheckedUpdateWithoutPersonaje_habita_reinoInput>
  }

  export type ReinosUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput = {
    create?: XOR<ReinosCreateWithoutPersonaje_habita_reinoInput, ReinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: ReinosCreateOrConnectWithoutPersonaje_habita_reinoInput
    upsert?: ReinosUpsertWithoutPersonaje_habita_reinoInput
    connect?: ReinosWhereUniqueInput
    update?: XOR<ReinosUpdateWithoutPersonaje_habita_reinoInput, ReinosUncheckedUpdateWithoutPersonaje_habita_reinoInput>
  }

  export type Personaje_habita_reinoCreateNestedManyWithoutReinoInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    createMany?: Personaje_habita_reinoCreateManyReinoInputEnvelope
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
  }

  export type Defensas_reinosCreateNestedManyWithoutReinoInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutReinoInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutReinoInput>
    createMany?: Defensas_reinosCreateManyReinoInputEnvelope
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
  }

  export type DiplomaciasCreateNestedManyWithoutReino1Input = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino1Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino1Input>
    createMany?: DiplomaciasCreateManyReino1InputEnvelope
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
  }

  export type DiplomaciasCreateNestedManyWithoutReino2Input = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino2Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino2Input>
    createMany?: DiplomaciasCreateManyReino2InputEnvelope
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
  }

  export type Personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    createMany?: Personaje_habita_reinoCreateManyReinoInputEnvelope
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
  }

  export type Defensas_reinosUncheckedCreateNestedManyWithoutReinoInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutReinoInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutReinoInput>
    createMany?: Defensas_reinosCreateManyReinoInputEnvelope
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
  }

  export type DiplomaciasUncheckedCreateNestedManyWithoutReino1Input = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino1Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino1Input>
    createMany?: DiplomaciasCreateManyReino1InputEnvelope
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
  }

  export type DiplomaciasUncheckedCreateNestedManyWithoutReino2Input = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino2Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino2Input>
    createMany?: DiplomaciasCreateManyReino2InputEnvelope
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
  }

  export type Personaje_habita_reinoUpdateManyWithoutReinoNestedInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    upsert?: Enumerable<Personaje_habita_reinoUpsertWithWhereUniqueWithoutReinoInput>
    createMany?: Personaje_habita_reinoCreateManyReinoInputEnvelope
    set?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<Personaje_habita_reinoUpdateWithWhereUniqueWithoutReinoInput>
    updateMany?: Enumerable<Personaje_habita_reinoUpdateManyWithWhereWithoutReinoInput>
    deleteMany?: Enumerable<Personaje_habita_reinoScalarWhereInput>
  }

  export type Defensas_reinosUpdateManyWithoutReinoNestedInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutReinoInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutReinoInput>
    upsert?: Enumerable<Defensas_reinosUpsertWithWhereUniqueWithoutReinoInput>
    createMany?: Defensas_reinosCreateManyReinoInputEnvelope
    set?: Enumerable<Defensas_reinosWhereUniqueInput>
    disconnect?: Enumerable<Defensas_reinosWhereUniqueInput>
    delete?: Enumerable<Defensas_reinosWhereUniqueInput>
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
    update?: Enumerable<Defensas_reinosUpdateWithWhereUniqueWithoutReinoInput>
    updateMany?: Enumerable<Defensas_reinosUpdateManyWithWhereWithoutReinoInput>
    deleteMany?: Enumerable<Defensas_reinosScalarWhereInput>
  }

  export type DiplomaciasUpdateManyWithoutReino1NestedInput = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino1Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino1Input>
    upsert?: Enumerable<DiplomaciasUpsertWithWhereUniqueWithoutReino1Input>
    createMany?: DiplomaciasCreateManyReino1InputEnvelope
    set?: Enumerable<DiplomaciasWhereUniqueInput>
    disconnect?: Enumerable<DiplomaciasWhereUniqueInput>
    delete?: Enumerable<DiplomaciasWhereUniqueInput>
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
    update?: Enumerable<DiplomaciasUpdateWithWhereUniqueWithoutReino1Input>
    updateMany?: Enumerable<DiplomaciasUpdateManyWithWhereWithoutReino1Input>
    deleteMany?: Enumerable<DiplomaciasScalarWhereInput>
  }

  export type DiplomaciasUpdateManyWithoutReino2NestedInput = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino2Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino2Input>
    upsert?: Enumerable<DiplomaciasUpsertWithWhereUniqueWithoutReino2Input>
    createMany?: DiplomaciasCreateManyReino2InputEnvelope
    set?: Enumerable<DiplomaciasWhereUniqueInput>
    disconnect?: Enumerable<DiplomaciasWhereUniqueInput>
    delete?: Enumerable<DiplomaciasWhereUniqueInput>
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
    update?: Enumerable<DiplomaciasUpdateWithWhereUniqueWithoutReino2Input>
    updateMany?: Enumerable<DiplomaciasUpdateManyWithWhereWithoutReino2Input>
    deleteMany?: Enumerable<DiplomaciasScalarWhereInput>
  }

  export type Personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput = {
    create?: XOR<Enumerable<Personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<Personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    upsert?: Enumerable<Personaje_habita_reinoUpsertWithWhereUniqueWithoutReinoInput>
    createMany?: Personaje_habita_reinoCreateManyReinoInputEnvelope
    set?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<Personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<Personaje_habita_reinoUpdateWithWhereUniqueWithoutReinoInput>
    updateMany?: Enumerable<Personaje_habita_reinoUpdateManyWithWhereWithoutReinoInput>
    deleteMany?: Enumerable<Personaje_habita_reinoScalarWhereInput>
  }

  export type Defensas_reinosUncheckedUpdateManyWithoutReinoNestedInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutReinoInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutReinoInput>
    upsert?: Enumerable<Defensas_reinosUpsertWithWhereUniqueWithoutReinoInput>
    createMany?: Defensas_reinosCreateManyReinoInputEnvelope
    set?: Enumerable<Defensas_reinosWhereUniqueInput>
    disconnect?: Enumerable<Defensas_reinosWhereUniqueInput>
    delete?: Enumerable<Defensas_reinosWhereUniqueInput>
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
    update?: Enumerable<Defensas_reinosUpdateWithWhereUniqueWithoutReinoInput>
    updateMany?: Enumerable<Defensas_reinosUpdateManyWithWhereWithoutReinoInput>
    deleteMany?: Enumerable<Defensas_reinosScalarWhereInput>
  }

  export type DiplomaciasUncheckedUpdateManyWithoutReino1NestedInput = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino1Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino1Input>
    upsert?: Enumerable<DiplomaciasUpsertWithWhereUniqueWithoutReino1Input>
    createMany?: DiplomaciasCreateManyReino1InputEnvelope
    set?: Enumerable<DiplomaciasWhereUniqueInput>
    disconnect?: Enumerable<DiplomaciasWhereUniqueInput>
    delete?: Enumerable<DiplomaciasWhereUniqueInput>
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
    update?: Enumerable<DiplomaciasUpdateWithWhereUniqueWithoutReino1Input>
    updateMany?: Enumerable<DiplomaciasUpdateManyWithWhereWithoutReino1Input>
    deleteMany?: Enumerable<DiplomaciasScalarWhereInput>
  }

  export type DiplomaciasUncheckedUpdateManyWithoutReino2NestedInput = {
    create?: XOR<Enumerable<DiplomaciasCreateWithoutReino2Input>, Enumerable<DiplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<DiplomaciasCreateOrConnectWithoutReino2Input>
    upsert?: Enumerable<DiplomaciasUpsertWithWhereUniqueWithoutReino2Input>
    createMany?: DiplomaciasCreateManyReino2InputEnvelope
    set?: Enumerable<DiplomaciasWhereUniqueInput>
    disconnect?: Enumerable<DiplomaciasWhereUniqueInput>
    delete?: Enumerable<DiplomaciasWhereUniqueInput>
    connect?: Enumerable<DiplomaciasWhereUniqueInput>
    update?: Enumerable<DiplomaciasUpdateWithWhereUniqueWithoutReino2Input>
    updateMany?: Enumerable<DiplomaciasUpdateManyWithWhereWithoutReino2Input>
    deleteMany?: Enumerable<DiplomaciasScalarWhereInput>
  }

  export type ReinosCreateNestedOneWithoutDefensas_reinosInput = {
    create?: XOR<ReinosCreateWithoutDefensas_reinosInput, ReinosUncheckedCreateWithoutDefensas_reinosInput>
    connectOrCreate?: ReinosCreateOrConnectWithoutDefensas_reinosInput
    connect?: ReinosWhereUniqueInput
  }

  export type DefensasCreateNestedOneWithoutDefensas_reinosInput = {
    create?: XOR<DefensasCreateWithoutDefensas_reinosInput, DefensasUncheckedCreateWithoutDefensas_reinosInput>
    connectOrCreate?: DefensasCreateOrConnectWithoutDefensas_reinosInput
    connect?: DefensasWhereUniqueInput
  }

  export type ReinosUpdateOneRequiredWithoutDefensas_reinosNestedInput = {
    create?: XOR<ReinosCreateWithoutDefensas_reinosInput, ReinosUncheckedCreateWithoutDefensas_reinosInput>
    connectOrCreate?: ReinosCreateOrConnectWithoutDefensas_reinosInput
    upsert?: ReinosUpsertWithoutDefensas_reinosInput
    connect?: ReinosWhereUniqueInput
    update?: XOR<ReinosUpdateWithoutDefensas_reinosInput, ReinosUncheckedUpdateWithoutDefensas_reinosInput>
  }

  export type DefensasUpdateOneRequiredWithoutDefensas_reinosNestedInput = {
    create?: XOR<DefensasCreateWithoutDefensas_reinosInput, DefensasUncheckedCreateWithoutDefensas_reinosInput>
    connectOrCreate?: DefensasCreateOrConnectWithoutDefensas_reinosInput
    upsert?: DefensasUpsertWithoutDefensas_reinosInput
    connect?: DefensasWhereUniqueInput
    update?: XOR<DefensasUpdateWithoutDefensas_reinosInput, DefensasUncheckedUpdateWithoutDefensas_reinosInput>
  }

  export type Defensas_reinosCreateNestedManyWithoutDefensaInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutDefensaInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutDefensaInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutDefensaInput>
    createMany?: Defensas_reinosCreateManyDefensaInputEnvelope
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
  }

  export type Defensas_reinosUncheckedCreateNestedManyWithoutDefensaInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutDefensaInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutDefensaInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutDefensaInput>
    createMany?: Defensas_reinosCreateManyDefensaInputEnvelope
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
  }

  export type Defensas_reinosUpdateManyWithoutDefensaNestedInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutDefensaInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutDefensaInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutDefensaInput>
    upsert?: Enumerable<Defensas_reinosUpsertWithWhereUniqueWithoutDefensaInput>
    createMany?: Defensas_reinosCreateManyDefensaInputEnvelope
    set?: Enumerable<Defensas_reinosWhereUniqueInput>
    disconnect?: Enumerable<Defensas_reinosWhereUniqueInput>
    delete?: Enumerable<Defensas_reinosWhereUniqueInput>
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
    update?: Enumerable<Defensas_reinosUpdateWithWhereUniqueWithoutDefensaInput>
    updateMany?: Enumerable<Defensas_reinosUpdateManyWithWhereWithoutDefensaInput>
    deleteMany?: Enumerable<Defensas_reinosScalarWhereInput>
  }

  export type Defensas_reinosUncheckedUpdateManyWithoutDefensaNestedInput = {
    create?: XOR<Enumerable<Defensas_reinosCreateWithoutDefensaInput>, Enumerable<Defensas_reinosUncheckedCreateWithoutDefensaInput>>
    connectOrCreate?: Enumerable<Defensas_reinosCreateOrConnectWithoutDefensaInput>
    upsert?: Enumerable<Defensas_reinosUpsertWithWhereUniqueWithoutDefensaInput>
    createMany?: Defensas_reinosCreateManyDefensaInputEnvelope
    set?: Enumerable<Defensas_reinosWhereUniqueInput>
    disconnect?: Enumerable<Defensas_reinosWhereUniqueInput>
    delete?: Enumerable<Defensas_reinosWhereUniqueInput>
    connect?: Enumerable<Defensas_reinosWhereUniqueInput>
    update?: Enumerable<Defensas_reinosUpdateWithWhereUniqueWithoutDefensaInput>
    updateMany?: Enumerable<Defensas_reinosUpdateManyWithWhereWithoutDefensaInput>
    deleteMany?: Enumerable<Defensas_reinosScalarWhereInput>
  }

  export type ReinosCreateNestedOneWithoutDiplomacia1Input = {
    create?: XOR<ReinosCreateWithoutDiplomacia1Input, ReinosUncheckedCreateWithoutDiplomacia1Input>
    connectOrCreate?: ReinosCreateOrConnectWithoutDiplomacia1Input
    connect?: ReinosWhereUniqueInput
  }

  export type ReinosCreateNestedOneWithoutDiplomacia2Input = {
    create?: XOR<ReinosCreateWithoutDiplomacia2Input, ReinosUncheckedCreateWithoutDiplomacia2Input>
    connectOrCreate?: ReinosCreateOrConnectWithoutDiplomacia2Input
    connect?: ReinosWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ReinosUpdateOneRequiredWithoutDiplomacia1NestedInput = {
    create?: XOR<ReinosCreateWithoutDiplomacia1Input, ReinosUncheckedCreateWithoutDiplomacia1Input>
    connectOrCreate?: ReinosCreateOrConnectWithoutDiplomacia1Input
    upsert?: ReinosUpsertWithoutDiplomacia1Input
    connect?: ReinosWhereUniqueInput
    update?: XOR<ReinosUpdateWithoutDiplomacia1Input, ReinosUncheckedUpdateWithoutDiplomacia1Input>
  }

  export type ReinosUpdateOneRequiredWithoutDiplomacia2NestedInput = {
    create?: XOR<ReinosCreateWithoutDiplomacia2Input, ReinosUncheckedCreateWithoutDiplomacia2Input>
    connectOrCreate?: ReinosCreateOrConnectWithoutDiplomacia2Input
    upsert?: ReinosUpsertWithoutDiplomacia2Input
    connect?: ReinosWhereUniqueInput
    update?: XOR<ReinosUpdateWithoutDiplomacia2Input, ReinosUncheckedUpdateWithoutDiplomacia2Input>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type KartsCreateWithoutPersonajeInput = {
    id: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
  }

  export type KartsUncheckedCreateWithoutPersonajeInput = {
    id: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
  }

  export type KartsCreateOrConnectWithoutPersonajeInput = {
    where: KartsWhereUniqueInput
    create: XOR<KartsCreateWithoutPersonajeInput, KartsUncheckedCreateWithoutPersonajeInput>
  }

  export type KartsCreateManyPersonajeInputEnvelope = {
    data: Enumerable<KartsCreateManyPersonajeInput>
    skipDuplicates?: boolean
  }

  export type Personaje_tiene_trabajoCreateWithoutPersonajeInput = {
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
    trabajo: TrabajosCreateNestedOneWithoutPersonaje_tiene_trabajoInput
  }

  export type Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput = {
    id_trabajo: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type Personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput = {
    where: Personaje_tiene_trabajoWhereUniqueInput
    create: XOR<Personaje_tiene_trabajoCreateWithoutPersonajeInput, Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>
  }

  export type Personaje_tiene_trabajoCreateManyPersonajeInputEnvelope = {
    data: Enumerable<Personaje_tiene_trabajoCreateManyPersonajeInput>
    skipDuplicates?: boolean
  }

  export type Personaje_habita_reinoCreateWithoutPersonajeInput = {
    fecha_registro: Date | string
    es_gobernante: boolean
    reino: ReinosCreateNestedOneWithoutPersonaje_habita_reinoInput
  }

  export type Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput = {
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type Personaje_habita_reinoCreateOrConnectWithoutPersonajeInput = {
    where: Personaje_habita_reinoWhereUniqueInput
    create: XOR<Personaje_habita_reinoCreateWithoutPersonajeInput, Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>
  }

  export type Personaje_habita_reinoCreateManyPersonajeInputEnvelope = {
    data: Enumerable<Personaje_habita_reinoCreateManyPersonajeInput>
    skipDuplicates?: boolean
  }

  export type KartsUpsertWithWhereUniqueWithoutPersonajeInput = {
    where: KartsWhereUniqueInput
    update: XOR<KartsUpdateWithoutPersonajeInput, KartsUncheckedUpdateWithoutPersonajeInput>
    create: XOR<KartsCreateWithoutPersonajeInput, KartsUncheckedCreateWithoutPersonajeInput>
  }

  export type KartsUpdateWithWhereUniqueWithoutPersonajeInput = {
    where: KartsWhereUniqueInput
    data: XOR<KartsUpdateWithoutPersonajeInput, KartsUncheckedUpdateWithoutPersonajeInput>
  }

  export type KartsUpdateManyWithWhereWithoutPersonajeInput = {
    where: KartsScalarWhereInput
    data: XOR<KartsUpdateManyMutationInput, KartsUncheckedUpdateManyWithoutKartInput>
  }

  export type KartsScalarWhereInput = {
    AND?: Enumerable<KartsScalarWhereInput>
    OR?: Enumerable<KartsScalarWhereInput>
    NOT?: Enumerable<KartsScalarWhereInput>
    id?: IntFilter | number
    modelo?: StringFilter | string
    color?: StringFilter | string
    velocidad_maxima?: IntNullableFilter | number | null
    id_personaje?: IntFilter | number
  }

  export type Personaje_tiene_trabajoUpsertWithWhereUniqueWithoutPersonajeInput = {
    where: Personaje_tiene_trabajoWhereUniqueInput
    update: XOR<Personaje_tiene_trabajoUpdateWithoutPersonajeInput, Personaje_tiene_trabajoUncheckedUpdateWithoutPersonajeInput>
    create: XOR<Personaje_tiene_trabajoCreateWithoutPersonajeInput, Personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>
  }

  export type Personaje_tiene_trabajoUpdateWithWhereUniqueWithoutPersonajeInput = {
    where: Personaje_tiene_trabajoWhereUniqueInput
    data: XOR<Personaje_tiene_trabajoUpdateWithoutPersonajeInput, Personaje_tiene_trabajoUncheckedUpdateWithoutPersonajeInput>
  }

  export type Personaje_tiene_trabajoUpdateManyWithWhereWithoutPersonajeInput = {
    where: Personaje_tiene_trabajoScalarWhereInput
    data: XOR<Personaje_tiene_trabajoUpdateManyMutationInput, Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonaje_tiene_trabajoInput>
  }

  export type Personaje_tiene_trabajoScalarWhereInput = {
    AND?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
    OR?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
    NOT?: Enumerable<Personaje_tiene_trabajoScalarWhereInput>
    id_trabajo?: IntFilter | number
    id_personaje?: IntFilter | number
    fecha_inicio?: DateTimeFilter | Date | string
    fecha_termino?: DateTimeNullableFilter | Date | string | null
  }

  export type Personaje_habita_reinoUpsertWithWhereUniqueWithoutPersonajeInput = {
    where: Personaje_habita_reinoWhereUniqueInput
    update: XOR<Personaje_habita_reinoUpdateWithoutPersonajeInput, Personaje_habita_reinoUncheckedUpdateWithoutPersonajeInput>
    create: XOR<Personaje_habita_reinoCreateWithoutPersonajeInput, Personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>
  }

  export type Personaje_habita_reinoUpdateWithWhereUniqueWithoutPersonajeInput = {
    where: Personaje_habita_reinoWhereUniqueInput
    data: XOR<Personaje_habita_reinoUpdateWithoutPersonajeInput, Personaje_habita_reinoUncheckedUpdateWithoutPersonajeInput>
  }

  export type Personaje_habita_reinoUpdateManyWithWhereWithoutPersonajeInput = {
    where: Personaje_habita_reinoScalarWhereInput
    data: XOR<Personaje_habita_reinoUpdateManyMutationInput, Personaje_habita_reinoUncheckedUpdateManyWithoutPersonaje_habita_reinoInput>
  }

  export type Personaje_habita_reinoScalarWhereInput = {
    AND?: Enumerable<Personaje_habita_reinoScalarWhereInput>
    OR?: Enumerable<Personaje_habita_reinoScalarWhereInput>
    NOT?: Enumerable<Personaje_habita_reinoScalarWhereInput>
    id_personaje?: IntFilter | number
    id_reino?: IntFilter | number
    fecha_registro?: DateTimeFilter | Date | string
    es_gobernante?: BoolFilter | boolean
  }

  export type PersonajesCreateWithoutKartInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: Personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesUncheckedCreateWithoutKartInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesCreateOrConnectWithoutKartInput = {
    where: PersonajesWhereUniqueInput
    create: XOR<PersonajesCreateWithoutKartInput, PersonajesUncheckedCreateWithoutKartInput>
  }

  export type PersonajesUpsertWithoutKartInput = {
    update: XOR<PersonajesUpdateWithoutKartInput, PersonajesUncheckedUpdateWithoutKartInput>
    create: XOR<PersonajesCreateWithoutKartInput, PersonajesUncheckedCreateWithoutKartInput>
  }

  export type PersonajesUpdateWithoutKartInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput
  }

  export type PersonajesUncheckedUpdateWithoutKartInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type TrabajosCreateWithoutPersonaje_tiene_trabajoInput = {
    id: number
    descripcion: string
    sueldo: number
  }

  export type TrabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput = {
    id: number
    descripcion: string
    sueldo: number
  }

  export type TrabajosCreateOrConnectWithoutPersonaje_tiene_trabajoInput = {
    where: TrabajosWhereUniqueInput
    create: XOR<TrabajosCreateWithoutPersonaje_tiene_trabajoInput, TrabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type PersonajesCreateWithoutPersonaje_tiene_trabajoInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    kart?: KartsCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    kart?: KartsUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesCreateOrConnectWithoutPersonaje_tiene_trabajoInput = {
    where: PersonajesWhereUniqueInput
    create: XOR<PersonajesCreateWithoutPersonaje_tiene_trabajoInput, PersonajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type TrabajosUpsertWithoutPersonaje_tiene_trabajoInput = {
    update: XOR<TrabajosUpdateWithoutPersonaje_tiene_trabajoInput, TrabajosUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
    create: XOR<TrabajosCreateWithoutPersonaje_tiene_trabajoInput, TrabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type TrabajosUpdateWithoutPersonaje_tiene_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type TrabajosUncheckedUpdateWithoutPersonaje_tiene_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type PersonajesUpsertWithoutPersonaje_tiene_trabajoInput = {
    update: XOR<PersonajesUpdateWithoutPersonaje_tiene_trabajoInput, PersonajesUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
    create: XOR<PersonajesCreateWithoutPersonaje_tiene_trabajoInput, PersonajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type PersonajesUpdateWithoutPersonaje_tiene_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    kart?: KartsUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput
  }

  export type PersonajesUncheckedUpdateWithoutPersonaje_tiene_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    kart?: KartsUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type Personaje_tiene_trabajoCreateWithoutTrabajoInput = {
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
    personaje: PersonajesCreateNestedOneWithoutPersonaje_tiene_trabajoInput
  }

  export type Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput = {
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type Personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput = {
    where: Personaje_tiene_trabajoWhereUniqueInput
    create: XOR<Personaje_tiene_trabajoCreateWithoutTrabajoInput, Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>
  }

  export type Personaje_tiene_trabajoCreateManyTrabajoInputEnvelope = {
    data: Enumerable<Personaje_tiene_trabajoCreateManyTrabajoInput>
    skipDuplicates?: boolean
  }

  export type Personaje_tiene_trabajoUpsertWithWhereUniqueWithoutTrabajoInput = {
    where: Personaje_tiene_trabajoWhereUniqueInput
    update: XOR<Personaje_tiene_trabajoUpdateWithoutTrabajoInput, Personaje_tiene_trabajoUncheckedUpdateWithoutTrabajoInput>
    create: XOR<Personaje_tiene_trabajoCreateWithoutTrabajoInput, Personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>
  }

  export type Personaje_tiene_trabajoUpdateWithWhereUniqueWithoutTrabajoInput = {
    where: Personaje_tiene_trabajoWhereUniqueInput
    data: XOR<Personaje_tiene_trabajoUpdateWithoutTrabajoInput, Personaje_tiene_trabajoUncheckedUpdateWithoutTrabajoInput>
  }

  export type Personaje_tiene_trabajoUpdateManyWithWhereWithoutTrabajoInput = {
    where: Personaje_tiene_trabajoScalarWhereInput
    data: XOR<Personaje_tiene_trabajoUpdateManyMutationInput, Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonaje_tiene_trabajoInput>
  }

  export type PersonajesCreateWithoutPersonaje_habita_reinoInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    kart?: KartsCreateNestedManyWithoutPersonajeInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesUncheckedCreateWithoutPersonaje_habita_reinoInput = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    kart?: KartsUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type PersonajesCreateOrConnectWithoutPersonaje_habita_reinoInput = {
    where: PersonajesWhereUniqueInput
    create: XOR<PersonajesCreateWithoutPersonaje_habita_reinoInput, PersonajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type ReinosCreateWithoutPersonaje_habita_reinoInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    defensas_reinos?: Defensas_reinosCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasCreateNestedManyWithoutReino1Input
    diplomacia2?: DiplomaciasCreateNestedManyWithoutReino2Input
  }

  export type ReinosUncheckedCreateWithoutPersonaje_habita_reinoInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    defensas_reinos?: Defensas_reinosUncheckedCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasUncheckedCreateNestedManyWithoutReino1Input
    diplomacia2?: DiplomaciasUncheckedCreateNestedManyWithoutReino2Input
  }

  export type ReinosCreateOrConnectWithoutPersonaje_habita_reinoInput = {
    where: ReinosWhereUniqueInput
    create: XOR<ReinosCreateWithoutPersonaje_habita_reinoInput, ReinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type PersonajesUpsertWithoutPersonaje_habita_reinoInput = {
    update: XOR<PersonajesUpdateWithoutPersonaje_habita_reinoInput, PersonajesUncheckedUpdateWithoutPersonaje_habita_reinoInput>
    create: XOR<PersonajesCreateWithoutPersonaje_habita_reinoInput, PersonajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type PersonajesUpdateWithoutPersonaje_habita_reinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    kart?: KartsUpdateManyWithoutPersonajeNestedInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput
  }

  export type PersonajesUncheckedUpdateWithoutPersonaje_habita_reinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    kart?: KartsUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_tiene_trabajo?: Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type ReinosUpsertWithoutPersonaje_habita_reinoInput = {
    update: XOR<ReinosUpdateWithoutPersonaje_habita_reinoInput, ReinosUncheckedUpdateWithoutPersonaje_habita_reinoInput>
    create: XOR<ReinosCreateWithoutPersonaje_habita_reinoInput, ReinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type ReinosUpdateWithoutPersonaje_habita_reinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    defensas_reinos?: Defensas_reinosUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUpdateManyWithoutReino1NestedInput
    diplomacia2?: DiplomaciasUpdateManyWithoutReino2NestedInput
  }

  export type ReinosUncheckedUpdateWithoutPersonaje_habita_reinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    defensas_reinos?: Defensas_reinosUncheckedUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    diplomacia2?: DiplomaciasUncheckedUpdateManyWithoutReino2NestedInput
  }

  export type Personaje_habita_reinoCreateWithoutReinoInput = {
    fecha_registro: Date | string
    es_gobernante: boolean
    personaje: PersonajesCreateNestedOneWithoutPersonaje_habita_reinoInput
  }

  export type Personaje_habita_reinoUncheckedCreateWithoutReinoInput = {
    id_personaje: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type Personaje_habita_reinoCreateOrConnectWithoutReinoInput = {
    where: Personaje_habita_reinoWhereUniqueInput
    create: XOR<Personaje_habita_reinoCreateWithoutReinoInput, Personaje_habita_reinoUncheckedCreateWithoutReinoInput>
  }

  export type Personaje_habita_reinoCreateManyReinoInputEnvelope = {
    data: Enumerable<Personaje_habita_reinoCreateManyReinoInput>
    skipDuplicates?: boolean
  }

  export type Defensas_reinosCreateWithoutReinoInput = {
    defensa: DefensasCreateNestedOneWithoutDefensas_reinosInput
  }

  export type Defensas_reinosUncheckedCreateWithoutReinoInput = {
    id_defensas: number
  }

  export type Defensas_reinosCreateOrConnectWithoutReinoInput = {
    where: Defensas_reinosWhereUniqueInput
    create: XOR<Defensas_reinosCreateWithoutReinoInput, Defensas_reinosUncheckedCreateWithoutReinoInput>
  }

  export type Defensas_reinosCreateManyReinoInputEnvelope = {
    data: Enumerable<Defensas_reinosCreateManyReinoInput>
    skipDuplicates?: boolean
  }

  export type DiplomaciasCreateWithoutReino1Input = {
    es_aliado?: boolean | null
    reino2: ReinosCreateNestedOneWithoutDiplomacia2Input
  }

  export type DiplomaciasUncheckedCreateWithoutReino1Input = {
    id_reino_2: number
    es_aliado?: boolean | null
  }

  export type DiplomaciasCreateOrConnectWithoutReino1Input = {
    where: DiplomaciasWhereUniqueInput
    create: XOR<DiplomaciasCreateWithoutReino1Input, DiplomaciasUncheckedCreateWithoutReino1Input>
  }

  export type DiplomaciasCreateManyReino1InputEnvelope = {
    data: Enumerable<DiplomaciasCreateManyReino1Input>
    skipDuplicates?: boolean
  }

  export type DiplomaciasCreateWithoutReino2Input = {
    es_aliado?: boolean | null
    reino1: ReinosCreateNestedOneWithoutDiplomacia1Input
  }

  export type DiplomaciasUncheckedCreateWithoutReino2Input = {
    id_reino_1: number
    es_aliado?: boolean | null
  }

  export type DiplomaciasCreateOrConnectWithoutReino2Input = {
    where: DiplomaciasWhereUniqueInput
    create: XOR<DiplomaciasCreateWithoutReino2Input, DiplomaciasUncheckedCreateWithoutReino2Input>
  }

  export type DiplomaciasCreateManyReino2InputEnvelope = {
    data: Enumerable<DiplomaciasCreateManyReino2Input>
    skipDuplicates?: boolean
  }

  export type Personaje_habita_reinoUpsertWithWhereUniqueWithoutReinoInput = {
    where: Personaje_habita_reinoWhereUniqueInput
    update: XOR<Personaje_habita_reinoUpdateWithoutReinoInput, Personaje_habita_reinoUncheckedUpdateWithoutReinoInput>
    create: XOR<Personaje_habita_reinoCreateWithoutReinoInput, Personaje_habita_reinoUncheckedCreateWithoutReinoInput>
  }

  export type Personaje_habita_reinoUpdateWithWhereUniqueWithoutReinoInput = {
    where: Personaje_habita_reinoWhereUniqueInput
    data: XOR<Personaje_habita_reinoUpdateWithoutReinoInput, Personaje_habita_reinoUncheckedUpdateWithoutReinoInput>
  }

  export type Personaje_habita_reinoUpdateManyWithWhereWithoutReinoInput = {
    where: Personaje_habita_reinoScalarWhereInput
    data: XOR<Personaje_habita_reinoUpdateManyMutationInput, Personaje_habita_reinoUncheckedUpdateManyWithoutPersonaje_habita_reinoInput>
  }

  export type Defensas_reinosUpsertWithWhereUniqueWithoutReinoInput = {
    where: Defensas_reinosWhereUniqueInput
    update: XOR<Defensas_reinosUpdateWithoutReinoInput, Defensas_reinosUncheckedUpdateWithoutReinoInput>
    create: XOR<Defensas_reinosCreateWithoutReinoInput, Defensas_reinosUncheckedCreateWithoutReinoInput>
  }

  export type Defensas_reinosUpdateWithWhereUniqueWithoutReinoInput = {
    where: Defensas_reinosWhereUniqueInput
    data: XOR<Defensas_reinosUpdateWithoutReinoInput, Defensas_reinosUncheckedUpdateWithoutReinoInput>
  }

  export type Defensas_reinosUpdateManyWithWhereWithoutReinoInput = {
    where: Defensas_reinosScalarWhereInput
    data: XOR<Defensas_reinosUpdateManyMutationInput, Defensas_reinosUncheckedUpdateManyWithoutDefensas_reinosInput>
  }

  export type Defensas_reinosScalarWhereInput = {
    AND?: Enumerable<Defensas_reinosScalarWhereInput>
    OR?: Enumerable<Defensas_reinosScalarWhereInput>
    NOT?: Enumerable<Defensas_reinosScalarWhereInput>
    id_reinos?: IntFilter | number
    id_defensas?: IntFilter | number
  }

  export type DiplomaciasUpsertWithWhereUniqueWithoutReino1Input = {
    where: DiplomaciasWhereUniqueInput
    update: XOR<DiplomaciasUpdateWithoutReino1Input, DiplomaciasUncheckedUpdateWithoutReino1Input>
    create: XOR<DiplomaciasCreateWithoutReino1Input, DiplomaciasUncheckedCreateWithoutReino1Input>
  }

  export type DiplomaciasUpdateWithWhereUniqueWithoutReino1Input = {
    where: DiplomaciasWhereUniqueInput
    data: XOR<DiplomaciasUpdateWithoutReino1Input, DiplomaciasUncheckedUpdateWithoutReino1Input>
  }

  export type DiplomaciasUpdateManyWithWhereWithoutReino1Input = {
    where: DiplomaciasScalarWhereInput
    data: XOR<DiplomaciasUpdateManyMutationInput, DiplomaciasUncheckedUpdateManyWithoutDiplomacia1Input>
  }

  export type DiplomaciasScalarWhereInput = {
    AND?: Enumerable<DiplomaciasScalarWhereInput>
    OR?: Enumerable<DiplomaciasScalarWhereInput>
    NOT?: Enumerable<DiplomaciasScalarWhereInput>
    id_reino_1?: IntFilter | number
    id_reino_2?: IntFilter | number
    es_aliado?: BoolNullableFilter | boolean | null
  }

  export type DiplomaciasUpsertWithWhereUniqueWithoutReino2Input = {
    where: DiplomaciasWhereUniqueInput
    update: XOR<DiplomaciasUpdateWithoutReino2Input, DiplomaciasUncheckedUpdateWithoutReino2Input>
    create: XOR<DiplomaciasCreateWithoutReino2Input, DiplomaciasUncheckedCreateWithoutReino2Input>
  }

  export type DiplomaciasUpdateWithWhereUniqueWithoutReino2Input = {
    where: DiplomaciasWhereUniqueInput
    data: XOR<DiplomaciasUpdateWithoutReino2Input, DiplomaciasUncheckedUpdateWithoutReino2Input>
  }

  export type DiplomaciasUpdateManyWithWhereWithoutReino2Input = {
    where: DiplomaciasScalarWhereInput
    data: XOR<DiplomaciasUpdateManyMutationInput, DiplomaciasUncheckedUpdateManyWithoutDiplomacia2Input>
  }

  export type ReinosCreateWithoutDefensas_reinosInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasCreateNestedManyWithoutReino1Input
    diplomacia2?: DiplomaciasCreateNestedManyWithoutReino2Input
  }

  export type ReinosUncheckedCreateWithoutDefensas_reinosInput = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasUncheckedCreateNestedManyWithoutReino1Input
    diplomacia2?: DiplomaciasUncheckedCreateNestedManyWithoutReino2Input
  }

  export type ReinosCreateOrConnectWithoutDefensas_reinosInput = {
    where: ReinosWhereUniqueInput
    create: XOR<ReinosCreateWithoutDefensas_reinosInput, ReinosUncheckedCreateWithoutDefensas_reinosInput>
  }

  export type DefensasCreateWithoutDefensas_reinosInput = {
    id: number
    defensa: string
  }

  export type DefensasUncheckedCreateWithoutDefensas_reinosInput = {
    id: number
    defensa: string
  }

  export type DefensasCreateOrConnectWithoutDefensas_reinosInput = {
    where: DefensasWhereUniqueInput
    create: XOR<DefensasCreateWithoutDefensas_reinosInput, DefensasUncheckedCreateWithoutDefensas_reinosInput>
  }

  export type ReinosUpsertWithoutDefensas_reinosInput = {
    update: XOR<ReinosUpdateWithoutDefensas_reinosInput, ReinosUncheckedUpdateWithoutDefensas_reinosInput>
    create: XOR<ReinosCreateWithoutDefensas_reinosInput, ReinosUncheckedCreateWithoutDefensas_reinosInput>
  }

  export type ReinosUpdateWithoutDefensas_reinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUpdateManyWithoutReino1NestedInput
    diplomacia2?: DiplomaciasUpdateManyWithoutReino2NestedInput
  }

  export type ReinosUncheckedUpdateWithoutDefensas_reinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    diplomacia2?: DiplomaciasUncheckedUpdateManyWithoutReino2NestedInput
  }

  export type DefensasUpsertWithoutDefensas_reinosInput = {
    update: XOR<DefensasUpdateWithoutDefensas_reinosInput, DefensasUncheckedUpdateWithoutDefensas_reinosInput>
    create: XOR<DefensasCreateWithoutDefensas_reinosInput, DefensasUncheckedCreateWithoutDefensas_reinosInput>
  }

  export type DefensasUpdateWithoutDefensas_reinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type DefensasUncheckedUpdateWithoutDefensas_reinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type Defensas_reinosCreateWithoutDefensaInput = {
    reino: ReinosCreateNestedOneWithoutDefensas_reinosInput
  }

  export type Defensas_reinosUncheckedCreateWithoutDefensaInput = {
    id_reinos: number
  }

  export type Defensas_reinosCreateOrConnectWithoutDefensaInput = {
    where: Defensas_reinosWhereUniqueInput
    create: XOR<Defensas_reinosCreateWithoutDefensaInput, Defensas_reinosUncheckedCreateWithoutDefensaInput>
  }

  export type Defensas_reinosCreateManyDefensaInputEnvelope = {
    data: Enumerable<Defensas_reinosCreateManyDefensaInput>
    skipDuplicates?: boolean
  }

  export type Defensas_reinosUpsertWithWhereUniqueWithoutDefensaInput = {
    where: Defensas_reinosWhereUniqueInput
    update: XOR<Defensas_reinosUpdateWithoutDefensaInput, Defensas_reinosUncheckedUpdateWithoutDefensaInput>
    create: XOR<Defensas_reinosCreateWithoutDefensaInput, Defensas_reinosUncheckedCreateWithoutDefensaInput>
  }

  export type Defensas_reinosUpdateWithWhereUniqueWithoutDefensaInput = {
    where: Defensas_reinosWhereUniqueInput
    data: XOR<Defensas_reinosUpdateWithoutDefensaInput, Defensas_reinosUncheckedUpdateWithoutDefensaInput>
  }

  export type Defensas_reinosUpdateManyWithWhereWithoutDefensaInput = {
    where: Defensas_reinosScalarWhereInput
    data: XOR<Defensas_reinosUpdateManyMutationInput, Defensas_reinosUncheckedUpdateManyWithoutDefensas_reinosInput>
  }

  export type ReinosCreateWithoutDiplomacia1Input = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutReinoInput
    defensas_reinos?: Defensas_reinosCreateNestedManyWithoutReinoInput
    diplomacia2?: DiplomaciasCreateNestedManyWithoutReino2Input
  }

  export type ReinosUncheckedCreateWithoutDiplomacia1Input = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    defensas_reinos?: Defensas_reinosUncheckedCreateNestedManyWithoutReinoInput
    diplomacia2?: DiplomaciasUncheckedCreateNestedManyWithoutReino2Input
  }

  export type ReinosCreateOrConnectWithoutDiplomacia1Input = {
    where: ReinosWhereUniqueInput
    create: XOR<ReinosCreateWithoutDiplomacia1Input, ReinosUncheckedCreateWithoutDiplomacia1Input>
  }

  export type ReinosCreateWithoutDiplomacia2Input = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoCreateNestedManyWithoutReinoInput
    defensas_reinos?: Defensas_reinosCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasCreateNestedManyWithoutReino1Input
  }

  export type ReinosUncheckedCreateWithoutDiplomacia2Input = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    defensas_reinos?: Defensas_reinosUncheckedCreateNestedManyWithoutReinoInput
    diplomacia1?: DiplomaciasUncheckedCreateNestedManyWithoutReino1Input
  }

  export type ReinosCreateOrConnectWithoutDiplomacia2Input = {
    where: ReinosWhereUniqueInput
    create: XOR<ReinosCreateWithoutDiplomacia2Input, ReinosUncheckedCreateWithoutDiplomacia2Input>
  }

  export type ReinosUpsertWithoutDiplomacia1Input = {
    update: XOR<ReinosUpdateWithoutDiplomacia1Input, ReinosUncheckedUpdateWithoutDiplomacia1Input>
    create: XOR<ReinosCreateWithoutDiplomacia1Input, ReinosUncheckedCreateWithoutDiplomacia1Input>
  }

  export type ReinosUpdateWithoutDiplomacia1Input = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    defensas_reinos?: Defensas_reinosUpdateManyWithoutReinoNestedInput
    diplomacia2?: DiplomaciasUpdateManyWithoutReino2NestedInput
  }

  export type ReinosUncheckedUpdateWithoutDiplomacia1Input = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    defensas_reinos?: Defensas_reinosUncheckedUpdateManyWithoutReinoNestedInput
    diplomacia2?: DiplomaciasUncheckedUpdateManyWithoutReino2NestedInput
  }

  export type ReinosUpsertWithoutDiplomacia2Input = {
    update: XOR<ReinosUpdateWithoutDiplomacia2Input, ReinosUncheckedUpdateWithoutDiplomacia2Input>
    create: XOR<ReinosCreateWithoutDiplomacia2Input, ReinosUncheckedCreateWithoutDiplomacia2Input>
  }

  export type ReinosUpdateWithoutDiplomacia2Input = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    defensas_reinos?: Defensas_reinosUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUpdateManyWithoutReino1NestedInput
  }

  export type ReinosUncheckedUpdateWithoutDiplomacia2Input = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: Personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    defensas_reinos?: Defensas_reinosUncheckedUpdateManyWithoutReinoNestedInput
    diplomacia1?: DiplomaciasUncheckedUpdateManyWithoutReino1NestedInput
  }

  export type KartsCreateManyPersonajeInput = {
    id: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
  }

  export type Personaje_tiene_trabajoCreateManyPersonajeInput = {
    id_trabajo: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type Personaje_habita_reinoCreateManyPersonajeInput = {
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type KartsUpdateWithoutPersonajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KartsUncheckedUpdateWithoutPersonajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KartsUncheckedUpdateManyWithoutKartInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Personaje_tiene_trabajoUpdateWithoutPersonajeInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trabajo?: TrabajosUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
  }

  export type Personaje_tiene_trabajoUncheckedUpdateWithoutPersonajeInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonaje_tiene_trabajoInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Personaje_habita_reinoUpdateWithoutPersonajeInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
    reino?: ReinosUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
  }

  export type Personaje_habita_reinoUncheckedUpdateWithoutPersonajeInput = {
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Personaje_habita_reinoUncheckedUpdateManyWithoutPersonaje_habita_reinoInput = {
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Personaje_tiene_trabajoCreateManyTrabajoInput = {
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type Personaje_tiene_trabajoUpdateWithoutTrabajoInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaje?: PersonajesUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
  }

  export type Personaje_tiene_trabajoUncheckedUpdateWithoutTrabajoInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Personaje_habita_reinoCreateManyReinoInput = {
    id_personaje: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type Defensas_reinosCreateManyReinoInput = {
    id_defensas: number
  }

  export type DiplomaciasCreateManyReino1Input = {
    id_reino_2: number
    es_aliado?: boolean | null
  }

  export type DiplomaciasCreateManyReino2Input = {
    id_reino_1: number
    es_aliado?: boolean | null
  }

  export type Personaje_habita_reinoUpdateWithoutReinoInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
    personaje?: PersonajesUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
  }

  export type Personaje_habita_reinoUncheckedUpdateWithoutReinoInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Defensas_reinosUpdateWithoutReinoInput = {
    defensa?: DefensasUpdateOneRequiredWithoutDefensas_reinosNestedInput
  }

  export type Defensas_reinosUncheckedUpdateWithoutReinoInput = {
    id_defensas?: IntFieldUpdateOperationsInput | number
  }

  export type Defensas_reinosUncheckedUpdateManyWithoutDefensas_reinosInput = {
    id_defensas?: IntFieldUpdateOperationsInput | number
  }

  export type DiplomaciasUpdateWithoutReino1Input = {
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reino2?: ReinosUpdateOneRequiredWithoutDiplomacia2NestedInput
  }

  export type DiplomaciasUncheckedUpdateWithoutReino1Input = {
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DiplomaciasUncheckedUpdateManyWithoutDiplomacia1Input = {
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DiplomaciasUpdateWithoutReino2Input = {
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reino1?: ReinosUpdateOneRequiredWithoutDiplomacia1NestedInput
  }

  export type DiplomaciasUncheckedUpdateWithoutReino2Input = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DiplomaciasUncheckedUpdateManyWithoutDiplomacia2Input = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    es_aliado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type Defensas_reinosCreateManyDefensaInput = {
    id_reinos: number
  }

  export type Defensas_reinosUpdateWithoutDefensaInput = {
    reino?: ReinosUpdateOneRequiredWithoutDefensas_reinosNestedInput
  }

  export type Defensas_reinosUncheckedUpdateWithoutDefensaInput = {
    id_reinos?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}